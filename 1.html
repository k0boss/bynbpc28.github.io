<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>白云PC28 - 双算法预测</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background-color: #ffffff;
            color: #333333;
            line-height: 1.6;
            padding: 15px;
            max-width: 800px;
            margin: 0 auto;
        }
        
        .container {
            background-color: #fff;
            border-radius: 8px;
            border: 1px solid #e0e0e0;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        }
        
        h1, h2, h3 {
            color: #333;
            margin-bottom: 12px;
            text-align: center;
        }
        
        h1 {
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 8px;
            margin-bottom: 15px;
            font-size: 18px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .loading {
            text-align: center;
            padding: 20px;
            font-size: 16px;
            color: #666;
        }
        
        .final-result-section {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid #e0e0e0;
            position: relative;
        }
        
        .final-result-content {
            font-family: monospace;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 12px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .final-result-content:hover {
            background-color: #f0f0f0;
        }
        
        .copy-btn {
            display: block;
            width: 100%;
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .copy-btn:hover {
            background-color: #555;
        }
        
        .copy-success {
            background-color: #4CAF50 !important;
            color: white;
        }
        
        .prediction-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }
        
        .prediction-item {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        
        .prediction-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .prediction-content {
            font-size: 16px;
            font-weight: bold;
        }
        
        .confidence {
            color: #888;
            font-size: 12px;
            margin-top: 5px;
        }
        
        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin: 15px 0 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid #e0e0e0;
        }
        
        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        
        .detail-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }
        
        .detail-label {
            color: #666;
        }
        
        .detail-value {
            font-weight: bold;
        }
        
        button {
            background-color: #333;
            color: #fff;
            border: none;
            border-radius: 6px;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
            margin: 5px;
            width: calc(100% - 10px);
        }
        
        button:hover {
            background-color: #555;
        }
        
        .button-container {
            text-align: center;
            margin: 15px 0;
        }
        
        .prediction-history {
            margin-top: 20px;
            overflow-x: auto;
        }
        
        .prediction-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 14px;
            border: 1px solid #e0e0e0;
        }
        
        .prediction-table th,
        .prediction-table td {
            border: 1px solid #e0e0e0;
            padding: 8px 10px;
            text-align: center;
        }
        
        .prediction-table th {
            background-color: #f5f5f5;
            font-weight: bold;
        }
        
        .prediction-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .hit {
            color: #4CAF50;
            font-weight: bold;
            font-size: 18px;
        }
        
        .miss {
            color: #F44336;
            font-weight: bold;
            font-size: 18px;
        }
        
        .stats-section {
            margin-top: 20px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        
        .stat-item {
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            padding: 10px;
        }
        
        .stat-title {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        
        .stat-value {
            font-size: 16px;
            font-weight: bold;
        }
        
        .accuracy-summary {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            text-align: center;
            font-weight: bold;
            border: 1px solid #e0e0e0;
        }
        
        .period-algorithm {
            background-color: #f0f7ff;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            border: 1px solid #cce5ff;
        }
        
        .kill-algorithm {
            background-color: #fff0f0;
            border-radius: 8px;
            padding: 12px;
            margin-top: 15px;
            border: 1px solid #ffcccc;
        }
        
        .period-calculation {
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            margin: 8px 0;
            padding: 8px;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #cce5ff;
        }
        
        .kill-calculation {
            font-family: monospace;
            font-size: 16px;
            text-align: center;
            margin: 8px 0;
            padding: 8px;
            background-color: #fff;
            border-radius: 4px;
            border: 1px solid #ffcccc;
        }
        
        /* 算法标签页样式 - 仿照片样式 */
        .algorithm-tabs {
            display: flex;
            background-color: #f5f5f5;
            border-radius: 8px;
            padding: 5px;
            margin-bottom: 20px;
            border: 1px solid #e0e0e0;
        }
        
        .algorithm-tab {
            flex: 1;
            text-align: center;
            padding: 12px;
            cursor: pointer;
            border-radius: 6px;
            font-weight: bold;
            transition: all 0.3s;
            background-color: transparent;
            border: none;
            color: #333;
        }
        
        .algorithm-tab.active {
            background-color: #333;
            color: white;
        }
        
        .algorithm-tab:hover:not(.active) {
            background-color: #e0e0e0;
        }
        
        /* 算法内容区域 */
        .algorithm-content {
            display: none;
        }
        
        .algorithm-content.active {
            display: block;
        }
        
        @media (max-width: 480px) {
            .prediction-grid, .stats-grid, .detail-grid {
                grid-template-columns: 1fr;
            }
            
            .prediction-table {
                font-size: 12px;
            }
            
            .prediction-table th,
            .prediction-table td {
                padding: 6px 8px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>白云PC28 - 双算法预测</h1>
            <p id="algorithmDescription">基于AI强势分析的预测算法 | 整合算法 + 杀组逻辑 + 双组预测</p>
        </div>
        
        <!-- 算法标签页 -->
        <div class="algorithm-tabs">
            <button class="algorithm-tab active" data-algorithm="1">算法1</button>
            <button class="algorithm-tab" data-algorithm="2">算法2</button>
        </div>
        
        <!-- 算法一内容 -->
        <div id="algorithm1-content" class="algorithm-content active">
            <div class="button-container">
                <button id="fetchData1">获取最新数据并预测</button>
            </div>
            
            <div id="loading1" class="loading" style="display: none;">
                正在获取数据并执行分析...
            </div>
            
            <div id="results1" style="display: none;">
                <!-- 最终结果区域 -->
                <div class="final-result-section">
                    <h3>最终预测结果</h3>
                    <div class="final-result-content" id="finalOutput1"></div>
                    <button class="copy-btn" id="copyFinalResult1">一键复制</button>
                </div>
                
                <div class="container">
                    <h3>详细分析</h3>
                    
                    <!-- 期号算法结果显示 -->
                    <div class="period-algorithm">
                        <div class="section-title">此算法仅供参考</div>
                        <div class="period-calculation" id="periodCalculation1"></div>
                        <div class="prediction-content" id="periodResult1"></div>
                    </div>
                    
                    <!-- 杀组算法结果显示 -->
                    <div class="kill-algorithm">
                        <div class="section-title">此算法仅供参考</div>
                        <div class="kill-calculation" id="killCalculation1"></div>
                        <div class="prediction-content" id="killAlgorithmResult1"></div>
                    </div>
                    
                    <div class="prediction-grid">
                        <div class="prediction-item">
                            <div class="prediction-title">双组预测</div>
                            <div class="prediction-content" id="finalResult1"></div>
                            <div class="confidence" id="baseConfidence1"></div>
                        </div>
                        
                        <div class="prediction-item">
                            <div class="prediction-title">杀组推荐</div>
                            <div class="prediction-content" id="killResult1"></div>
                            <div class="confidence" id="killConfidence1"></div>
                        </div>
                    </div>
                    
                    <div class="section-title">球预测分析</div>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <span class="detail-label">预测A球</span>
                            <span class="detail-value" id="ballA1"></span>
                        </div>
                        
                        <div class="detail-item">
                            <span class="detail-label">预测B球</span>
                            <span class="detail-value" id="ballB1"></span>
                        </div>
                        
                        <div class="detail-item">
                            <span class="detail-label">预测C球</span>
                            <span class="detail-value" id="ballC1"></span>
                        </div>
                        
                        <div class="detail-item">
                            <span class="detail-label">预测和值</span>
                            <span class="detail-value" id="predictedSum1"></span>
                        </div>
                    </div>
                    
                    <div class="section-title">特码推荐</div>
                    <div class="prediction-item">
                        <div class="prediction-content" id="specialCodes1"></div>
                    </div>
                </div>
                
                <div class="prediction-history">
                    <h3>近期预测记录</h3>
                    <table class="prediction-table" id="predictionTable1">
                        <thead>
                            <tr>
                                <th>期号</th>
                                <th>时间</th>
                                <th>开奖号码</th>
                                <th>杀组</th>
                                <th>双组预测</th>
                                <th>结果</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- 预测记录将通过JavaScript动态生成 -->
                        </tbody>
                    </table>
                    
                    <div class="accuracy-summary" id="accuracySummary1">
                        <!-- 准确率统计将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 算法二内容 -->
        <div id="algorithm2-content" class="algorithm-content">
            <div class="button-container">
                <button id="fetchData2">获取最新数据并预测</button>
            </div>
            
            <div id="loading2" class="loading" style="display: none;">
                正在获取数据并执行分析...
            </div>
            
            <div id="results2" style="display: none;">
                <!-- 最终结果区域 -->
                <div class="final-result-section">
                    <h3>最终预测结果</h3>
                    <div class="final-result-content" id="finalOutput2"></div>
                    <button class="copy-btn" id="copyFinalResult2">一键复制</button>
                </div>
                
                <div class="container">
                    <h3>详细分析</h3>
                    
                    <!-- 期号算法结果显示 -->
                    <div class="period-algorithm">
                        <div class="section-title">此算法仅供参考</div>
                        <div class="period-calculation" id="periodCalculation2"></div>
                        <div class="prediction-content" id="periodResult2"></div>
                    </div>
                    
                    <!-- 杀组算法结果显示 -->
                    <div class="kill-algorithm">
                        <div class="section-title">此算法仅供参考</div>
                        <div class="kill-calculation" id="killCalculation2"></div>
                        <div class="prediction-content" id="killAlgorithmResult2"></div>
                    </div>
                    
                    <div class="prediction-grid">
                        <div class="prediction-item">
                            <div class="prediction-title">双组预测</div>
                            <div class="prediction-content" id="finalResult2"></div>
                            <div class="confidence" id="baseConfidence2"></div>
                        </div>
                        
                        <div class="prediction-item">
                            <div class="prediction-title">杀组推荐</div>
                            <div class="prediction-content" id="killResult2"></div>
                            <div class="confidence" id="killConfidence2"></div>
                        </div>
                    </div>
                    
                    <div class="section-title">球预测分析</div>
                    <div class="detail-grid">
                        <div class="detail-item">
                            <span class="detail-label">预测A球</span>
                            <span class="detail-value" id="ballA2"></span>
                        </div>
                        
                        <div class="detail-item">
                            <span class="detail-label">预测B球</span>
                            <span class="detail-value" id="ballB2"></span>
                        </div>
                        
                        <div class="detail-item">
                            <span class="detail-label">预测C球</span>
                            <span class="detail-value" id="ballC2"></span>
                        </div>
                        
                        <div class="detail-item">
                            <span class="detail-label">预测和值</span>
                            <span class="detail-value" id="predictedSum2"></span>
                        </div>
                    </div>
                    
                    <div class="section-title">特码推荐</div>
                    <div class="prediction-item">
                        <div class="prediction-content" id="specialCodes2"></div>
                    </div>
                </div>
                
                <div class="prediction-history">
                    <h3>近期预测记录</h3>
                    <table class="prediction-table" id="predictionTable2">
                        <thead>
                            <tr>
                                <th>期号</th>
                                <th>时间</th>
                                <th>开奖号码</th>
                                <th>杀组</th>
                                <th>双组预测</th>
                                <th>结果</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- 预测记录将通过JavaScript动态生成 -->
                        </tbody>
                    </table>
                    
                    <div class="accuracy-summary" id="accuracySummary2">
                        <!-- 准确率统计将通过JavaScript动态生成 -->
                    </div>
                </div>
            </div>
        </div>
        
        <div class="container" style="margin-top: 15px; text-align: center; font-size: 12px; color: #888;">
            <p>温馨提示: 彩票有风险，投注需谨慎</p>
            <p>本预测仅供参考，不构成投资建议</p>
        </div>
    </div>

    <script>
        // 算法一预测器类
        class PC28Predictor {
            constructor() {
                // 球预测参数
                this.ball_analysis = {
                    'ball_distributions': [new Array(10).fill(0), new Array(10).fill(0), new Array(10).fill(0)],
                    'ball_transitions': [
                        Array.from({length: 10}, () => new Array(10).fill(0)),
                        Array.from({length: 10}, () => new Array(10).fill(0)),
                        Array.from({length: 10}, () => new Array(10).fill(0))
                    ],
                    'ball_sequences': [[], [], []],
                    'type_history': [],
                    'kill_history': [],
                    'time_patterns': []
                };
                
                // 动态数据窗口
                this.data_window = [];
                
                // 时间分析参数
                this.time_analysis = {
                    'hourly_patterns': new Array(24).fill(0),
                    'daily_patterns': new Array(7).fill(0),
                    'recent_trends': [],
                    'volatility_index': 0.5,
                    'trend_strength': 0.5,
                    'momentum_index': 0.5
                };
                
                // 算法状态
                this.algorithm_state = {
                    'last_prediction': null,
                    'last_kill': null,
                    'prediction_count': {},
                    'kill_count': {},
                    'type_balance': {"大单": 0, "大双": 0, "小单": 0, "小双": 0},
                    'success_rate': 0.5,
                    'adaptation_factor': 1.0,
                    'pattern_memory': [],
                    'trend_memory': [],
                    'strong_type': null,
                    'ai_analysis_state': {},
                    'code_analysis_history': []
                };
                
                // AI学习参数
                this.ai_parameters = {
                    'learning_rate': 0.1,
                    'exploration_rate': 0.15,
                    'pattern_threshold': 0.75,
                    'confidence_decay': 0.92,
                    'trend_sensitivity': 1.3,
                    'momentum_weight': 0.8,
                    'code_analysis_depth': 20
                };
                
                // 趋势分析参数
                this.trend_analysis = {
                    'short_term_trend': 0,
                    'medium_term_trend': 0,
                    'long_term_trend': 0,
                    'trend_consistency': 0.5,
                    'volatility_level': 0.5,
                    'pattern_recognition': {},
                    'code_frequency': new Array(28).fill(0)
                };
                
                // 定义特码分类
                this.code_categories = {
                    "小单": [1, 3, 5, 7, 9, 11, 13],
                    "小双": [0, 2, 4, 6, 8, 10, 12],
                    "大单": [15, 17, 19, 21, 23, 25, 27],
                    "大双": [14, 16, 18, 20, 22, 24, 26]
                };
                
                // 尾数分析
                this.tail_analysis = {
                    'tail_frequency': new Array(10).fill(0),
                    'tail_patterns': {},
                    'recent_tails': []
                };
                
                // 预测历史记录
                this.prediction_history = [];
                
                // 时间动态杀组分析
                this.time_kill_analysis = {
                    'hourly_kill_patterns': new Array(24).fill(0),
                    'daily_kill_patterns': new Array(7).fill(0),
                    'recent_kill_success': [],
                    'kill_adaptation_rate': 1.0
                };
            }
            
            // 获取彩票数据
            async fetchLotteryData(limit = 100) {
                try {
                    const response = await fetch(`https://pc28.help/kj.json?limit=${limit}`);
                    const data = await response.json();
                    return data.data || [];
                } catch (error) {
                    console.error('获取开奖数据失败:', error);
                    // 返回模拟数据作为备用
                    return this.generateMockData(limit);
                }
            }
            
            // 生成模拟数据（备用）
            generateMockData(limit) {
                const mockData = [];
                let period = 3361000;
                
                for (let i = 0; i < limit; i++) {
                    const num1 = Math.floor(Math.random() * 10);
                    const num2 = Math.floor(Math.random() * 10);
                    const num3 = Math.floor(Math.random() * 10);
                    const sum = num1 + num2 + num3;
                    
                    let type;
                    if (sum <= 13) {
                        type = (sum % 2 === 0) ? "小双" : "小单";
                    } else {
                        type = (sum % 2 === 0) ? "大双" : "大单";
                    }
                    
                    mockData.push({
                        qihao: (period + i).toString(),
                        opennum: `${num1},${num2},${num3}`,
                        opentime: new Date(Date.now() - i * 5 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19)
                    });
                }
                
                return mockData;
            }
            
            // 解析网络开奖数据
            parseNetworkData(rawData) {
                const periods = [];
                
                for (const item of rawData) {
                    try {
                        const numbersStr = item.opennum || '';
                        const numbers = numbersStr.includes(',') ? 
                            numbersStr.split(',') : numbersStr.split('+');
                        const [num1, num2, num3] = numbers.map(Number);
                        const sumVal = num1 + num2 + num3;
                        
                        let lotteryType;
                        if (sumVal <= 13) {
                            lotteryType = (sumVal % 2 === 0) ? "小双" : "小单";
                        } else {
                            lotteryType = (sumVal % 2 === 0) ? "大双" : "大单";
                        }
                        
                        // 解析时间
                        const openTime = item.opentime || '';
                        let hour, weekday, timeStr;
                        
                        if (openTime) {
                            try {
                                const timeObj = new Date(openTime.replace(' ', 'T'));
                                hour = timeObj.getHours();
                                weekday = timeObj.getDay();
                                // 提取时间部分 (HH:MM)
                                timeStr = openTime.split(' ')[1] ? openTime.split(' ')[1].substring(0, 5) : '00:00';
                            } catch (e) {
                                hour = Math.floor(Math.random() * 24);
                                weekday = Math.floor(Math.random() * 7);
                                timeStr = '00:00';
                            }
                        } else {
                            hour = Math.floor(Math.random() * 24);
                            weekday = Math.floor(Math.random() * 7);
                            timeStr = '00:00';
                        }
                        
                        periods.push({
                            'period': item.qihao || '',
                            'numbers': [num1, num2, num3],
                            'sum': sumVal,
                            'type': lotteryType,
                            'time': openTime,
                            'timeStr': timeStr,
                            'hour': hour,
                            'weekday': weekday
                        });
                    } catch (error) {
                        console.error('解析数据出错:', error);
                        continue;
                    }
                }
                
                return periods;
            }
            
            // 新增：基于期号、和值等数据的算法
            calculatePeriodBasedPrediction(data) {
                if (data.length < 3) {
                    return null;
                }

                try {
                    // 获取前三期数据
                    const current = data[0];    // 最新一期
                    const prev1 = data[1];      // 前一期
                    const prev2 = data[2];      // 前两期

                    // A = 前两期期号的最后一位
                    const periodA = prev2.period;
                    const A = parseInt(periodA.charAt(periodA.length - 1));

                    // B = 前一期的和值
                    const B = prev1.sum;

                    // C = 最新一期的和值的个位数
                    const C = current.sum % 10;

                    // D = 近3期的b球总合 (第二个球)
                    const D = current.numbers[1] + prev1.numbers[1] + prev2.numbers[1];

                    // 计算 S = A + B + C
                    const S = A + B + C;

                    // 计算可能开奖的结果 = S - D + 1
                    let result = S - D + 1;

                    // 确保结果在有效范围内 (0-27)
                    if (result < 0) result = 0;
                    if (result > 27) result = 27;

                    // 转换为类型
                    let predictedType;
                    if (result <= 13) {
                        predictedType = (result % 2 === 0) ? "小双" : "小单";
                    } else {
                        predictedType = (result % 2 === 0) ? "大双" : "大单";
                    }

                    return {
                        type: predictedType,
                        result: result,
                        calculation: `${A}+${B}+${C}=${S}-${D}+1=${result}`
                    };
                } catch (error) {
                    console.error('期号算法计算错误:', error);
                    return null;
                }
            }

            // 新增：基于新杀组算法的预测
            calculateKillByNewAlgorithm(data) {
                if (data.length < 3) {
                    return null;
                }

                try {
                    // 获取前三期数据
                    const current = data[0];    // 最新一期
                    const prev1 = data[1];      // 前一期
                    const prev2 = data[2];      // 前两期

                    // A = 近三期和值的个位数总和
                    const A = (current.sum % 10) + (prev1.sum % 10) + (prev2.sum % 10);

                    // B = 前两期的b球
                    const B = prev1.numbers[1] + prev2.numbers[1];

                    // C = 最新一期开的和值
                    const C = current.sum;

                    // 计算 (A + B × 2) - C + 2
                    let killValue = (A + B * 2) - C + 2;

                    // 确保结果在有效范围内 (0-27)
                    if (killValue < 0) killValue = 0;
                    if (killValue > 27) killValue = 27;

                    // 转换为类型
                    let killType;
                    if (killValue <= 13) {
                        killType = (killValue % 2 === 0) ? "小双" : "小单";
                    } else {
                        killType = (killValue % 2 === 0) ? "大双" : "大单";
                    }

                    return {
                        type: killType,
                        value: killValue,
                        calculation: `(${A}+${B}×2)-${C}+2=${killValue}`,
                        components: {
                            A: A,
                            B: B,
                            C: C
                        }
                    };
                } catch (error) {
                    console.error('杀组算法计算错误:', error);
                    return null;
                }
            }

            // 分析动态走势
            analyzeDynamicTrends(data) {
                if (data.length < 10) return;
                
                // 提取和值序列
                const sums = data.map(item => item.sum);
                const types = data.map(item => item.type);
                
                // 计算不同时间尺度的趋势
                if (sums.length >= 5) {
                    this.trend_analysis.short_term_trend = this.calculateTrendDirection(sums.slice(0, 5));
                }
                
                if (sums.length >= 10) {
                    this.trend_analysis.medium_term_trend = this.calculateTrendDirection(sums.slice(0, 10));
                }
                
                if (sums.length >= 20) {
                    this.trend_analysis.long_term_trend = this.calculateTrendDirection(sums.slice(0, 20));
                }
                
                // 计算趋势一致性
                this.calculateTrendConsistency(sums);
                
                // 计算波动水平
                this.calculateVolatilityLevel(sums);
                
                // 识别模式
                this.identifyPatterns(types, sums);
                
                // 计算动量指数
                this.calculateMomentumIndex(data);
                
                // 更新特码频率分析
                this.updateCodeFrequencyAnalysis(data);
                
                // 更新尾数分析
                this.updateTailAnalysis(data);
                
                // 更新时间动态杀组分析
                this.updateTimeKillAnalysis(data);
            }
            
            // 更新时间动态杀组分析
            updateTimeKillAnalysis(data) {
                if (data.length < 10) return;
                
                // 分析每小时杀组成功率
                const hourlyKillSuccess = new Array(24).fill(0);
                const hourlyKillCount = new Array(24).fill(0);
                
                // 分析每周各天杀组成功率
                const dailyKillSuccess = new Array(7).fill(0);
                const dailyKillCount = new Array(7).fill(0);
                
                // 遍历历史数据，计算杀组成功率
                for (let i = 0; i < data.length - 1; i++) {
                    const current = data[i];
                    const next = data[i + 1];
                    
                    // 杀组成功：当前杀组不等于下一期类型
                    const killSuccess = current.type !== next.type ? 1 : 0;
                    
                    // 更新小时杀组统计
                    hourlyKillSuccess[current.hour] += killSuccess;
                    hourlyKillCount[current.hour]++;
                    
                    // 更新星期杀组统计
                    dailyKillSuccess[current.weekday] += killSuccess;
                    dailyKillCount[current.weekday]++;
                }
                
                // 计算成功率
                for (let i = 0; i < 24; i++) {
                    if (hourlyKillCount[i] > 0) {
                        this.time_kill_analysis.hourly_kill_patterns[i] = 
                            hourlyKillSuccess[i] / hourlyKillCount[i];
                    }
                }
                
                for (let i = 0; i < 7; i++) {
                    if (dailyKillCount[i] > 0) {
                        this.time_kill_analysis.daily_kill_patterns[i] = 
                            dailyKillSuccess[i] / dailyKillCount[i];
                    }
                }
                
                // 更新近期杀组成功率
                const recentKills = data.slice(0, 20);
                let recentSuccess = 0;
                for (let i = 0; i < recentKills.length - 1; i++) {
                    if (recentKills[i].type !== recentKills[i + 1].type) {
                        recentSuccess++;
                    }
                }
                
                this.time_kill_analysis.recent_kill_success.push(
                    recentKills.length > 1 ? recentSuccess / (recentKills.length - 1) : 0.5
                );
                
                if (this.time_kill_analysis.recent_kill_success.length > 10) {
                    this.time_kill_analysis.recent_kill_success.shift();
                }
                
                // 计算杀组适应率
                const recentAvg = this.time_kill_analysis.recent_kill_success.reduce((a, b) => a + b, 0) / 
                                 this.time_kill_analysis.recent_kill_success.length;
                this.time_kill_analysis.kill_adaptation_rate = Math.min(1.2, Math.max(0.8, recentAvg * 1.5));
            }
            
            // 更新尾数分析
            updateTailAnalysis(data) {
                if (data.length < 5) return;
                
                // 计算尾数频率
                const tailCounts = new Array(10).fill(0);
                
                for (const item of data.slice(0, 50)) {
                    const tail = item.sum % 10;
                    tailCounts[tail]++;
                }
                
                const total = tailCounts.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    this.tail_analysis.tail_frequency = tailCounts.map(count => count / total);
                }
                
                // 更新近期尾数
                this.tail_analysis.recent_tails = data.slice(0, 20).map(item => item.sum % 10);
                
                // 识别尾数模式
                this.identifyTailPatterns(this.tail_analysis.recent_tails);
            }
            
            // 识别尾数模式
            identifyTailPatterns(tails) {
                if (tails.length < 8) return;
                
                const tailPatterns = {};
                
                for (let i = 0; i < tails.length - 3; i++) {
                    const pattern = tails.slice(i, i + 3).join(',');
                    const nextTail = tails[i + 3];
                    
                    if (!tailPatterns[pattern]) {
                        tailPatterns[pattern] = [];
                    }
                    
                    tailPatterns[pattern].push(nextTail);
                }
                
                this.tail_analysis.tail_patterns = tailPatterns;
            }
            
            // 预测尾数
            predictTailNumbers(count = 4) {
                const tailScores = new Array(10).fill(0);
                
                // 1. 基于频率
                for (let i = 0; i < 10; i++) {
                    tailScores[i] += this.tail_analysis.tail_frequency[i] * 40;
                }
                
                // 2. 基于遗漏分析
                const recentTails = this.tail_analysis.recent_tails;
                for (let i = 0; i < 10; i++) {
                    if (recentTails.includes(i)) {
                        const lastIndex = recentTails.lastIndexOf(i);
                        const omission = recentTails.length - 1 - lastIndex;
                        tailScores[i] += (omission / recentTails.length) * 30;
                    } else {
                        // 从未出现，给高分
                        tailScores[i] += 35;
                    }
                }
                
                // 3. 基于模式识别
                if (recentTails.length >= 3) {
                    const currentPattern = recentTails.slice(0, 3).join(',');
                    if (this.tail_analysis.tail_patterns[currentPattern]) {
                        const patternTails = this.tail_analysis.tail_patterns[currentPattern];
                        const tailCounts = {};
                        
                        for (const tail of patternTails) {
                            tailCounts[tail] = (tailCounts[tail] || 0) + 1;
                        }
                        
                        for (const [tail, count] of Object.entries(tailCounts)) {
                            const probability = count / patternTails.length;
                            tailScores[parseInt(tail)] += probability * 30;
                        }
                    }
                }
                
                // 选择得分最高的尾数
                const tailWithScores = tailScores.map((score, index) => ({tail: index, score}));
                tailWithScores.sort((a, b) => b.score - a.score);
                
                return tailWithScores.slice(0, count).map(item => item.tail);
            }
            
            // 计算趋势方向
            calculateTrendDirection(dataSeries) {
                if (dataSeries.length < 3) return 0;
                
                const x = Array.from({length: dataSeries.length}, (_, i) => i);
                const y = dataSeries;
                
                // 简单线性回归计算斜率
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
                const sumX2 = x.reduce((sum, val) => sum + val * val, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                
                // 归一化斜率
                return Math.tanh(slope / 5.0);
            }
            
            // 计算趋势一致性
            calculateTrendConsistency(sums) {
                if (sums.length < 5) {
                    this.trend_analysis.trend_consistency = 0.5;
                    return;
                }
                
                const windows = [5, 8, 12];
                const consistencies = [];
                
                for (const window of windows) {
                    if (sums.length >= window) {
                        const windowSums = sums.slice(0, window);
                        const trendDirections = [];
                        
                        for (let i = 1; i < windowSums.length; i++) {
                            const direction = windowSums[i] > windowSums[i-1] ? 1 : 
                                            (windowSums[i] < windowSums[i-1] ? -1 : 0);
                            trendDirections.push(direction);
                        }
                        
                        if (trendDirections.length > 0) {
                            const consistency = trendDirections.filter(d => d === trendDirections[0]).length / trendDirections.length;
                            consistencies.push(consistency);
                        }
                    }
                }
                
                if (consistencies.length > 0) {
                    this.trend_analysis.trend_consistency = consistencies.reduce((a, b) => a + b, 0) / consistencies.length;
                } else {
                    this.trend_analysis.trend_consistency = 0.5;
                }
            }
            
            // 计算波动水平
            calculateVolatilityLevel(sums) {
                if (sums.length < 5) {
                    this.trend_analysis.volatility_level = 0.5;
                    return;
                }
                
                const windowSums = sums.slice(0, 15);
                const mean = windowSums.reduce((a, b) => a + b, 0) / windowSums.length;
                const variance = windowSums.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / windowSums.length;
                const stdDev = Math.sqrt(variance);
                
                const volatility = stdDev / mean;
                const normalizedVolatility = Math.min(1.0, volatility * 3);
                this.trend_analysis.volatility_level = normalizedVolatility;
            }
            
            // 识别模式
            identifyPatterns(types, sums) {
                if (types.length < 8) return;
                
                const typePatterns = {};
                
                for (let i = 0; i < types.length - 3; i++) {
                    const pattern = types.slice(i, i + 3);
                    const nextType = types[i + 3];
                    
                    const patternKey = pattern.join(',');
                    
                    if (!typePatterns[patternKey]) {
                        typePatterns[patternKey] = [];
                    }
                    
                    if (nextType) {
                        typePatterns[patternKey].push(nextType);
                    }
                }
                
                const patternAccuracy = {};
                for (const [pattern, outcomes] of Object.entries(typePatterns)) {
                    if (outcomes.length >= 2) {
                        const counter = {};
                        for (const outcome of outcomes) {
                            counter[outcome] = (counter[outcome] || 0) + 1;
                        }
                        
                        let mostCommon = null;
                        let maxCount = 0;
                        
                        for (const [type, count] of Object.entries(counter)) {
                            if (count > maxCount) {
                                mostCommon = type;
                                maxCount = count;
                            }
                        }
                        
                        const accuracy = maxCount / outcomes.length;
                        patternAccuracy[pattern] = [mostCommon, accuracy];
                    }
                }
                
                this.trend_analysis.pattern_recognition = patternAccuracy;
            }
            
            // 计算动量指数
            calculateMomentumIndex(data) {
                if (data.length < 8) {
                    this.time_analysis.momentum_index = 0.5;
                    return;
                }
                
                const sums = data.slice(0, 15).map(item => item.sum);
                const momentumIndicators = [];
                
                if (sums.length >= 4) {
                    const shortMomentum = (sums[0] - sums[3]) / 3.0;
                    momentumIndicators.push(shortMomentum);
                }
                
                if (sums.length >= 7) {
                    const mediumMomentum = (sums[0] - sums[6]) / 6.0;
                    momentumIndicators.push(mediumMomentum);
                }
                
                if (sums.length >= 11) {
                    const longMomentum = (sums[0] - sums[10]) / 10.0;
                    momentumIndicators.push(longMomentum);
                }
                
                if (momentumIndicators.length > 0) {
                    const avgMomentum = momentumIndicators.reduce((a, b) => a + b, 0) / momentumIndicators.length;
                    const normalizedMomentum = Math.tanh(avgMomentum / 5.0) * 0.5 + 0.5;
                    this.time_analysis.momentum_index = normalizedMomentum;
                } else {
                    this.time_analysis.momentum_index = 0.5;
                }
            }
            
            // 更新特码频率分析
            updateCodeFrequencyAnalysis(data) {
                if (data.length < 5) return;
                
                // 使用时间衰减权重
                const weights = Array.from({length: Math.min(30, data.length)}, (_, i) => Math.exp(-i * 0.15));
                const weightSum = weights.reduce((a, b) => a + b, 0);
                const normalizedWeights = weights.map(w => w / weightSum);
                
                // 重置频率数组
                this.trend_analysis.code_frequency = new Array(28).fill(0);
                
                // 加权更新频率
                for (let idx = 0; idx < Math.min(30, data.length); idx++) {
                    const sumVal = data[idx].sum;
                    const weight = idx < normalizedWeights.length ? normalizedWeights[idx] : 1.0;
                    
                    if (sumVal >= 0 && sumVal <= 27) {
                        this.trend_analysis.code_frequency[sumVal] += weight;
                    }
                }
                
                // 归一化
                const total = this.trend_analysis.code_frequency.reduce((a, b) => a + b, 0);
                if (total > 0) {
                    this.trend_analysis.code_frequency = this.trend_analysis.code_frequency.map(val => val / total);
                }
            }
            
            // 基于球预测的核心预测算法
            sumBasedPrediction(data) {
                if (data.length < 5) {
                    return ["大单大双", "大双", [0, 0, 0], [50, 50, 50]];
                }
                
                this.updateBallAnalysis(data);
                
                const [predictedBalls, ballConfidences] = this.predictBallsEnhanced(data);
                
                const [finalResult, killResult] = this.analyzeAIStateAndKill(data, predictedBalls);
                
                this.adaptiveLearning(data, 0.5);
                
                return [finalResult, killResult, predictedBalls, ballConfidences];
            }
            
            // 更新球分析数据
            updateBallAnalysis(data) {
                if (data.length < 2) return;
                
                // 重置分布
                for (let i = 0; i < 3; i++) {
                    this.ball_analysis.ball_distributions[i] = new Array(10).fill(0);
                }
                
                // 时间权重
                const timeWeights = Array.from({length: Math.min(80, data.length)}, (_, i) => Math.exp(-i * 0.1));
                const weightSum = timeWeights.reduce((a, b) => a + b, 0);
                const normalizedWeights = timeWeights.map(w => w / weightSum);
                
                for (let idx = 0; idx < Math.min(80, data.length); idx++) {
                    const numbers = data[idx].numbers;
                    const weight = idx < normalizedWeights.length ? normalizedWeights[idx] : 1.0;
                    
                    for (let i = 0; i < 3; i++) {
                        if (numbers[i] >= 0 && numbers[i] <= 9) {
                            this.ball_analysis.ball_distributions[i][numbers[i]] += weight;
                            this.ball_analysis.ball_sequences[i].push(numbers[i]);
                            
                            // 保持序列长度
                            if (this.ball_analysis.ball_sequences[i].length > 25) {
                                this.ball_analysis.ball_sequences[i].shift();
                            }
                        }
                    }
                }
                
                // 归一化分布
                for (let i = 0; i < 3; i++) {
                    const total = this.ball_analysis.ball_distributions[i].reduce((a, b) => a + b, 0);
                    if (total > 0) {
                        this.ball_analysis.ball_distributions[i] = this.ball_analysis.ball_distributions[i].map(val => val / total);
                    }
                }
                
                // 更新转移矩阵
                for (let ballIdx = 0; ballIdx < 3; ballIdx++) {
                    // 重置转移矩阵
                    this.ball_analysis.ball_transitions[ballIdx] = Array.from({length: 10}, () => new Array(10).fill(0));
                    
                    for (let i = 0; i < Math.min(data.length - 1, 50); i++) {
                        const fromBall = data[i].numbers[ballIdx];
                        const toBall = data[i + 1].numbers[ballIdx];
                        const weight = i < normalizedWeights.length ? normalizedWeights[i] : 1.0;
                        
                        if (fromBall >= 0 && fromBall <= 9 && toBall >= 0 && toBall <= 9) {
                            this.ball_analysis.ball_transitions[ballIdx][fromBall][toBall] += weight;
                        }
                    }
                    
                    // 归一化转移矩阵
                    for (let from = 0; from < 10; from++) {
                        const rowSum = this.ball_analysis.ball_transitions[ballIdx][from].reduce((a, b) => a + b, 0);
                        if (rowSum > 0) {
                            for (let to = 0; to < 10; to++) {
                                this.ball_analysis.ball_transitions[ballIdx][from][to] /= rowSum;
                            }
                        }
                    }
                }
            }
            
            // 增强的球预测算法
            predictBallsEnhanced(data) {
                if (data.length < 5) {
                    const randomBalls = [
                        Math.floor(Math.random() * 10),
                        Math.floor(Math.random() * 10),
                        Math.floor(Math.random() * 10)
                    ];
                    return [randomBalls, [50, 50, 50]];
                }
                
                this.analyzeTypePatterns(data);
                this.analyzeTimePatterns(data);
                this.analyzeDynamicTrends(data);
                
                const currentBalls = data[0].numbers;
                const predictedBalls = [];
                const confidenceScores = [];
                
                for (let ballIdx = 0; ballIdx < 3; ballIdx++) {
                    const predictions = [];
                    const weights = [];
                    const methodScores = [];
                    
                    // 1. 基于转移矩阵
                    const [transPred, transScore] = this.predictByTransition(ballIdx, currentBalls[ballIdx]);
                    predictions.push(transPred);
                    weights.push(1.2 * this.algorithm_state.adaptation_factor);
                    methodScores.push(transScore);
                    
                    // 2. 基于近期趋势
                    const [trendPred, trendScore] = this.predictByTrend(ballIdx, data);
                    predictions.push(trendPred);
                    weights.push(1.1 * this.time_analysis.trend_strength);
                    methodScores.push(trendScore);
                    
                    // 3. 基于分布
                    const [distPred, distScore] = this.predictByDistribution(ballIdx);
                    predictions.push(distPred);
                    weights.push(0.9);
                    methodScores.push(distScore);
                    
                    // 加权投票
                    const ballScores = new Array(10).fill(0);
                    
                    for (let i = 0; i < predictions.length; i++) {
                        const pred = predictions[i];
                        const weight = weights[i];
                        const score = methodScores[i];
                        
                        ballScores[pred] += weight * score;
                    }
                    
                    // 选择最佳球
                    let bestBall = 0;
                    let maxScore = ballScores[0];
                    
                    for (let i = 1; i < 10; i++) {
                        if (ballScores[i] > maxScore) {
                            maxScore = ballScores[i];
                            bestBall = i;
                        }
                    }
                    
                    const confidence = Math.min(95, maxScore / weights.reduce((a, b) => a + b, 0) * 100);
                    
                    predictedBalls.push(bestBall);
                    confidenceScores.push(confidence);
                }
                
                return [predictedBalls, confidenceScores];
            }
            
            // 基于转移矩阵预测
            predictByTransition(ballIdx, currentBall) {
                if (currentBall < 0 || currentBall > 9) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const transitionProbs = this.ball_analysis.ball_transitions[ballIdx][currentBall];
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                
                const combinedProbs = transitionProbs.map((prob, i) => prob * (distribution[i] + 0.01));
                
                let bestBall = 0;
                let maxProb = combinedProbs[0];
                
                for (let i = 1; i < 10; i++) {
                    if (combinedProbs[i] > maxProb) {
                        maxProb = combinedProbs[i];
                        bestBall = i;
                    }
                }
                
                const confidence = Math.min(0.9, maxProb / combinedProbs.reduce((a, b) => a + b, 0) * 2);
                
                return [bestBall, confidence];
            }
            
            // 基于趋势预测
            predictByTrend(ballIdx, data) {
                if (data.length < 3) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const recentBalls = data.slice(0, 8).map(item => item.numbers[ballIdx]);
                
                if (recentBalls.length >= 5) {
                    const trendWeights = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8].slice(0, recentBalls.length);
                    const weightSum = trendWeights.reduce((a, b) => a + b, 0);
                    const normalizedWeights = trendWeights.map(w => w / weightSum);
                    
                    const weightedAvg = recentBalls.reduce((sum, val, i) => sum + val * normalizedWeights[i], 0);
                    
                    const shortAvg = recentBalls.slice(0, 3).reduce((sum, val, i) => sum + val * normalizedWeights[i], 0) / 
                                   normalizedWeights.slice(0, 3).reduce((a, b) => a + b, 0);
                    const longAvg = weightedAvg;
                    
                    const trendDirection = shortAvg > longAvg ? 1 : -1;
                    const trendStrength = Math.min(1.0, Math.abs(shortAvg - longAvg) / 3.0);
                    
                    const adjustment = trendDirection * trendStrength * 2;
                    let predicted = Math.round(weightedAvg + adjustment);
                    predicted = Math.max(0, Math.min(9, predicted));
                    
                    const confidence = 0.5 + trendStrength * 0.3;
                    
                    return [predicted, confidence];
                }
                
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                let bestBall = 0;
                let maxProb = distribution[0];
                
                for (let i = 1; i < 10; i++) {
                    if (distribution[i] > maxProb) {
                        maxProb = distribution[i];
                        bestBall = i;
                    }
                }
                
                return [bestBall, 0.6];
            }
            
            // 基于分布预测
            predictByDistribution(ballIdx) {
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                
                // 如果分布比较均匀，使用序列中的热门球
                const maxVal = Math.max(...distribution);
                const minVal = Math.min(...distribution);
                
                if (maxVal - minVal < 0.1) {
                    const sequence = this.ball_analysis.ball_sequences[ballIdx];
                    if (sequence.length >= 3) {
                        const recentCounter = {};
                        for (const ball of sequence.slice(-8)) {
                            recentCounter[ball] = (recentCounter[ball] || 0) + 1;
                        }
                        
                        let hotBall = 0;
                        let maxCount = 0;
                        
                        for (const [ball, count] of Object.entries(recentCounter)) {
                            if (count > maxCount) {
                                maxCount = count;
                                hotBall = parseInt(ball);
                            }
                        }
                        
                        return [hotBall, 0.55];
                    }
                }
                
                let bestBall = 0;
                let maxProb = distribution[0];
                
                for (let i = 1; i < 10; i++) {
                    if (distribution[i] > maxProb) {
                        maxProb = distribution[i];
                        bestBall = i;
                    }
                }
                
                const confidence = Math.min(0.8, maxProb * 1.5);
                
                return [bestBall, confidence];
            }
            
            // 分析类型模式
            analyzeTypePatterns(data) {
                if (data.length < 10) return;
                
                const recentTypes = data.slice(0, 20).map(item => item.type);
                const typeCounter = {};
                
                for (const type of recentTypes) {
                    typeCounter[type] = (typeCounter[type] || 0) + 1;
                }
                
                const total = recentTypes.length;
                
                for (const typeName of ["大单", "大双", "小单", "小双"]) {
                    const count = typeCounter[typeName] || 0;
                    this.algorithm_state.type_balance[typeName] = total > 0 ? count / total : 0.25;
                }
            }
            
            // 分析时间模式
            analyzeTimePatterns(data) {
                if (data.length < 10) return;
                
                const hourlyCounts = new Array(24).fill(0);
                for (const item of data) {
                    hourlyCounts[item.hour]++;
                }
                
                const totalHours = data.length;
                if (totalHours > 0) {
                    this.time_analysis.hourly_patterns = hourlyCounts.map(count => count / totalHours);
                }
                
                const dailyCounts = new Array(7).fill(0);
                for (const item of data) {
                    dailyCounts[item.weekday]++;
                }
                
                const totalDays = data.length;
                if (totalDays > 0) {
                    this.time_analysis.daily_patterns = dailyCounts.map(count => count / totalDays);
                }
                
                const recentSums = data.slice(0, 10).map(item => item.sum);
                if (recentSums.length >= 5) {
                    const trendValues = [];
                    for (let i = 1; i < recentSums.length; i++) {
                        trendValues.push(recentSums[i] - recentSums[i-1]);
                    }
                    
                    if (trendValues.length > 0) {
                        const avgTrend = trendValues.reduce((a, b) => a + b, 0) / trendValues.length;
                        const trendStrength = Math.min(1.0, Math.abs(avgTrend) / 5.0);
                        this.time_analysis.trend_strength = trendStrength;
                    }
                }
            }
            
            // 自适应学习算法
            adaptiveLearning(data, predictionAccuracy) {
                this.algorithm_state.success_rate = 
                    this.algorithm_state.success_rate * 0.9 + predictionAccuracy * 0.1;
                
                if (predictionAccuracy > 0.6) {
                    this.algorithm_state.adaptation_factor *= 1.05;
                } else {
                    this.algorithm_state.adaptation_factor *= 0.95;
                }
                
                this.algorithm_state.adaptation_factor = Math.max(0.5, Math.min(2.0, this.algorithm_state.adaptation_factor));
                
                if (data.length >= 5) {
                    const recentPattern = data.slice(0, 5).map(item => item.type);
                    this.algorithm_state.pattern_memory.push(recentPattern);
                    
                    if (this.algorithm_state.pattern_memory.length > 15) {
                        this.algorithm_state.pattern_memory.shift();
                    }
                }
            }
            
            // 同时分析AI状态和杀组推荐
            analyzeAIStateAndKill(data, predictedBalls) {
                if (data.length < 10) {
                    return ["大单大双", "大双"];
                }
                
                this.analyzeDynamicTrends(data);
                
                const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
                const predictedType = this.sumToType(predictedSum);
                
                const strongType = this.calculateStrongType(data);
                this.algorithm_state.strong_type = strongType;
                
                this.updateAIAnalysisState(data, strongType);
                
                // 获取期号算法预测结果
                const periodPrediction = this.calculatePeriodBasedPrediction(data);

                const finalTypes = this.generateDoublePredictionBasedOnStrongType(data, strongType, periodPrediction);

                // 获取新杀组算法预测结果
                const killPrediction = this.calculateKillByNewAlgorithm(data);

                const killType = this.selectKillBasedOnAIState(finalTypes, predictedType, data, strongType, periodPrediction, killPrediction);

                return [finalTypes.join(''), killType];
            }
            
            // 计算强势类型
            calculateStrongType(data) {
                if (data.length < 10) return "大单";
                
                const typeScores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                // 1. 基于趋势分析
                const trendScore = this.calculateTrendBasedScore(data);
                for (const [typeName, score] of Object.entries(trendScore)) {
                    typeScores[typeName] += score * 0.3;
                }
                
                // 2. 基于动量分析
                const momentumScore = this.calculateMomentumBasedScore(data);
                for (const [typeName, score] of Object.entries(momentumScore)) {
                    typeScores[typeName] += score * 0.25;
                }
                
                // 3. 基于模式识别
                const patternScore = this.calculatePatternBasedScore(data);
                for (const [typeName, score] of Object.entries(patternScore)) {
                    typeScores[typeName] += score * 0.2;
                }
                
                // 4. 基于遗漏分析
                const omissionScore = this.calculateOmissionBasedScore(data);
                for (const [typeName, score] of Object.entries(omissionScore)) {
                    typeScores[typeName] += score * 0.15;
                }
                
                // 5. 基于时间模式
                const timeScore = this.calculateTimeBasedScore(data);
                for (const [typeName, score] of Object.entries(timeScore)) {
                    typeScores[typeName] += score * 0.1;
                }
                
                let maxType = "大单";
                let maxScore = typeScores["大单"];
                
                for (const [typeName, score] of Object.entries(typeScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        maxType = typeName;
                    }
                }
                
                return maxType;
            }
            
            // 基于趋势分析的分数计算
            calculateTrendBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const shortTrend = this.trend_analysis.short_term_trend;
                const trendConsistency = this.trend_analysis.trend_consistency;
                
                if (Math.abs(shortTrend) > 0.1 && trendConsistency > 0.6) {
                    const currentSum = data[0].sum;
                    
                    if (shortTrend > 0) {
                        if (currentSum <= 13) {
                            scores["大单"] = 0.8;
                            scores["大双"] = 0.7;
                        } else {
                            scores["大单"] = 0.9;
                            scores["大双"] = 0.8;
                        }
                    } else {
                        if (currentSum >= 14) {
                            scores["小单"] = 0.8;
                            scores["小双"] = 0.7;
                        } else {
                            scores["小单"] = 0.9;
                            scores["小双"] = 0.8;
                        }
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于动量分析的分数计算
            calculateMomentumBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const momentum = this.time_analysis.momentum_index;
                
                if (momentum > 0.7) {
                    const currentType = data[0].type;
                    scores[currentType] = 0.9;
                    
                    const oppositeTypes = this.getOppositeTypes(currentType);
                    for (const oppType of oppositeTypes) {
                        scores[oppType] = 0.2;
                    }
                } else if (momentum < 0.3) {
                    const currentType = data[0].type;
                    scores[currentType] = 0.3;
                    
                    for (const typeName of Object.keys(scores)) {
                        if (typeName !== currentType) {
                            scores[typeName] = 0.7;
                        }
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于模式识别的分数计算
            calculatePatternBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const recentTypes = data.slice(0, 5).map(item => item.type);
                
                const pattern = recentTypes.join(',');
                if (this.trend_analysis.pattern_recognition[pattern]) {
                    const [nextType, accuracy] = this.trend_analysis.pattern_recognition[pattern];
                    if (accuracy > 0.6) {
                        scores[nextType] = accuracy;
                    } else {
                        for (const typeName of Object.keys(scores)) {
                            scores[typeName] = 0.5;
                        }
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于遗漏分析的分数计算
            calculateOmissionBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const recentTypes = data.slice(0, 20).map(item => item.type);
                const allTypes = ["大单", "大双", "小单", "小双"];
                
                const omissions = {};
                for (const typeName of allTypes) {
                    if (recentTypes.includes(typeName)) {
                        const lastIndex = recentTypes.length - 1 - [...recentTypes].reverse().indexOf(typeName);
                        omissions[typeName] = lastIndex;
                    } else {
                        omissions[typeName] = recentTypes.length;
                    }
                }
                
                const maxOmission = Math.max(...Object.values(omissions));
                for (const [typeName, omission] of Object.entries(omissions)) {
                    const omissionFactor = omission / maxOmission;
                    scores[typeName] = omissionFactor;
                }
                
                return scores;
            }
            
            // 基于时间模式的分数计算
            calculateTimeBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const currentHour = data[0].hour;
                
                const hourData = data.filter(item => item.hour === currentHour);
                if (hourData.length >= 3) {
                    const hourTypes = hourData.map(item => item.type);
                    const typeCounter = {};
                    
                    for (const type of hourTypes) {
                        typeCounter[type] = (typeCounter[type] || 0) + 1;
                    }
                    
                    const total = hourTypes.length;
                    
                    for (const [typeName, count] of Object.entries(typeCounter)) {
                        scores[typeName] = count / total;
                    }
                } else {
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.25;
                    }
                }
                
                return scores;
            }
            
            // 获取相反类型
            getOppositeTypes(typeName) {
                const opposites = {
                    "大单": ["小双"],
                    "大双": ["小单"],
                    "小单": ["大双"],
                    "小双": ["大单"]
                };
                return opposites[typeName] || [];
            }
            
            // 更新AI分析状态
            updateAIAnalysisState(data, strongType) {
                this.algorithm_state.ai_analysis_state = {
                    'strong_type': strongType,
                    'trend_direction': this.trend_analysis.short_term_trend,
                    'trend_consistency': this.trend_analysis.trend_consistency,
                    'momentum_index': this.time_analysis.momentum_index,
                    'volatility_level': this.trend_analysis.volatility_level,
                    'timestamp': new Date()
                };
            }
            
            // 基于强势类型生成双组预测
            generateDoublePredictionBasedOnStrongType(data, strongType, periodPrediction) {
                const finalTypes = [strongType];

                const allTypes = ["大单", "大双", "小单", "小双"];
                const remainingTypes = allTypes.filter(t => t !== strongType);

                // 增强的双组选择逻辑，考虑期号算法
                const secondTypeScores = {};
                for (const typeName of remainingTypes) {
                    let score = 0;

                    // 1. 趋势分析分数
                    const trendScore = this.calculateTrendBasedScore(data);
                    score += trendScore[typeName] * 0.25;

                    // 2. 遗漏分析分数
                    const omissionScore = this.calculateOmissionBasedScore(data);
                    score += omissionScore[typeName] * 0.2;

                    // 3. 模式识别分数
                    const patternScore = this.calculatePatternBasedScore(data);
                    score += patternScore[typeName] * 0.15;

                    // 4. 时间模式分数
                    const timeScore = this.calculateTimeBasedScore(data);
                    score += timeScore[typeName] * 0.1;

                    // 5. 类型平衡分数
                    const balanceScore = 1 - (this.algorithm_state.type_balance[typeName] || 0.25);
                    score += balanceScore * 0.1;

                    // 6. 新增：期号算法分数（重要因素）
                    if (periodPrediction && periodPrediction.type === typeName) {
                        score += 0.4;
                    }

                    secondTypeScores[typeName] = score;
                }

                // 选择分数最高的作为第二类型
                let secondType = remainingTypes[0];
                let maxScore = secondTypeScores[secondType];

                for (const [typeName, score] of Object.entries(secondTypeScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        secondType = typeName;
                    }
                }

                // 如果期号算法预测的类型不在最终结果中，考虑替换
                if (periodPrediction && 
                    !finalTypes.includes(periodPrediction.type) && 
                    this.isPeriodPredictionReliable(data, periodPrediction)) {
                    
                    const periodType = periodPrediction.type;
                    if (remainingTypes.includes(periodType)) {
                        secondType = periodType;
                    }
                }

                finalTypes.push(secondType);

                return finalTypes;
            }

            // 新增：评估期号算法的可靠性
            isPeriodPredictionReliable(data, periodPrediction) {
                if (data.length < 10) return false;

                let correctCount = 0;
                let totalTests = 0;

                for (let i = 0; i < data.length - 3; i++) {
                    const testData = data.slice(i, i + 3);
                    const actualNext = data[i + 3];
                    
                    try {
                        const testPrediction = this.calculatePeriodBasedPrediction(testData);
                        if (testPrediction && testPrediction.type === actualNext.type) {
                            correctCount++;
                        }
                        totalTests++;
                    } catch (e) {
                        continue;
                    }
                }

                const accuracy = totalTests > 0 ? correctCount / totalTests : 0;
                
                return accuracy > 0.6;
            }
            
            // 基于AI分析状态选择杀组 - 增强版（整合新杀组算法）
            selectKillBasedOnAIState(finalTypes, predictedType, data, strongType, periodPrediction, killPrediction) {
                const allTypes = ["大单", "大双", "小单", "小双"];

                let killCandidates = allTypes.filter(
                    t => t !== strongType && 
                         !finalTypes.includes(t) && 
                         t !== predictedType &&
                         (!periodPrediction || t !== periodPrediction.type)
                );

                if (killCandidates.length === 0) {
                    killCandidates = allTypes.filter(t => 
                        t !== strongType && 
                        (!periodPrediction || t !== periodPrediction.type)
                    );
                }

                if (killCandidates.length === 0) {
                    killCandidates = allTypes;
                }

                const killScores = {};
                for (const candidate of killCandidates) {
                    let score = 0;
                    
                    // 1. 遗漏值分数
                    const recentTypes = data.slice(0, 25).map(item => item.type);
                    if (recentTypes.includes(candidate)) {
                        const lastIndex = recentTypes.length - 1 - [...recentTypes].reverse().indexOf(candidate);
                        const omission = lastIndex;
                        score += (omission / recentTypes.length) * 30;
                    } else {
                        score += 35;
                    }
                    
                    // 2. 时间动态杀组分析
                    const currentHour = data[0].hour;
                    const currentWeekday = data[0].weekday;
                    
                    const hourlyKillSuccess = this.time_kill_analysis.hourly_kill_patterns[currentHour] || 0.5;
                    score += hourlyKillSuccess * 20;
                    
                    const dailyKillSuccess = this.time_kill_analysis.daily_kill_patterns[currentWeekday] || 0.5;
                    score += dailyKillSuccess * 15;
                    
                    // 3. 趋势分析分数
                    const currentTrend = this.trend_analysis.short_term_trend;
                    if (Math.abs(currentTrend) > 0.15) {
                        if (currentTrend > 0) {
                            if (["小单", "小双"].includes(candidate)) {
                                score += 15;
                            }
                        } else {
                            if (["大单", "大双"].includes(candidate)) {
                                score += 15;
                            }
                        }
                    }
                    
                    // 4. 历史使用频率
                    const killCount = this.algorithm_state.kill_count[candidate] || 0;
                    score += (1 - Math.min(killCount / 12, 1)) * 10;
                    
                    // 5. 类型平衡分数
                    const typeBalance = this.algorithm_state.type_balance[candidate] || 0.25;
                    score += (1 - typeBalance) * 10;
                    
                    // 6. 新增：如果期号算法预测了某个类型，避免将其作为杀组
                    if (periodPrediction && candidate === periodPrediction.type) {
                        score -= 25;
                    }

                    // 7. 新增：如果新杀组算法预测了某个类型，优先选择它作为杀组
                    if (killPrediction && candidate === killPrediction.type) {
                        score += 40;
                    }

                    killScores[candidate] = score;
                }
                
                if (Object.keys(killScores).length > 0) {
                    let bestKill = killCandidates[0];
                    let maxScore = killScores[bestKill];
                    
                    for (const [candidate, score] of Object.entries(killScores)) {
                        if (score > maxScore) {
                            maxScore = score;
                            bestKill = candidate;
                        }
                    }
                    
                    this.algorithm_state.kill_count[bestKill] = (this.algorithm_state.kill_count[bestKill] || 0) + 1;
                    return bestKill;
                } else {
                    const candidates = allTypes.filter(t => 
                        t !== strongType && 
                        (!periodPrediction || t !== periodPrediction.type)
                    );
                    const bestKill = candidates.length > 0 ? 
                        candidates[Math.floor(Math.random() * candidates.length)] : 
                        allTypes[Math.floor(Math.random() * allTypes.length)];
                    this.algorithm_state.kill_count[bestKill] = (this.algorithm_state.kill_count[bestKill] || 0) + 1;
                    return bestKill;
                }
            }
            
            // 和值转类型
            sumToType(sumVal) {
                if (sumVal <= 13) {
                    return (sumVal % 2 === 0) ? "小双" : "小单";
                } else {
                    return (sumVal % 2 === 0) ? "大双" : "大单";
                }
            }
            
            // 计算置信度
            calculateConfidence(data, finalResult, killResult, ballConfidences) {
                if (data.length < 5) {
                    return [60, 55, 50];
                }
                
                let baseConfidence = 65;
                let killConfidence = 60;
                let ballConfidence = ballConfidences.length > 0 ? 
                    ballConfidences.reduce((a, b) => a + b, 0) / ballConfidences.length : 50;
                
                if (data.length >= 80) {
                    baseConfidence += 20;
                    killConfidence += 15;
                    ballConfidence += 15;
                } else if (data.length >= 50) {
                    baseConfidence += 15;
                    killConfidence += 10;
                    ballConfidence += 10;
                } else if (data.length >= 30) {
                    baseConfidence += 10;
                    killConfidence += 8;
                    ballConfidence += 8;
                } else if (data.length >= 20) {
                    baseConfidence += 5;
                    killConfidence += 5;
                    ballConfidence += 5;
                }
                
                if (ballConfidence > 75) {
                    baseConfidence += 12;
                    killConfidence += 8;
                } else if (ballConfidence > 65) {
                    baseConfidence += 8;
                    killConfidence += 5;
                }
                
                const predictedTypes = [];
                for (let i = 0; i < finalResult.length; i += 2) {
                    predictedTypes.push(finalResult.substring(i, i + 2));
                }
                
                if (!predictedTypes.includes(killResult)) {
                    baseConfidence += 8;
                    killConfidence += 8;
                }
                
                const strongType = this.algorithm_state.strong_type;
                if (strongType && predictedTypes.includes(strongType)) {
                    baseConfidence += 10;
                    killConfidence += 5;
                }
                
                const currentHour = new Date().getHours();
                const hourConfidence = this.time_analysis.hourly_patterns[currentHour] * 20;
                baseConfidence += hourConfidence;
                killConfidence += hourConfidence * 0.8;
                
                const trendConfidence = this.time_analysis.trend_strength * 15;
                baseConfidence += trendConfidence;
                ballConfidence += trendConfidence;
                
                const adaptationConfidence = (this.algorithm_state.adaptation_factor - 0.5) * 10;
                baseConfidence += adaptationConfidence;
                
                const consistencyConfidence = this.trend_analysis.trend_consistency * 12;
                baseConfidence += consistencyConfidence;
                killConfidence += consistencyConfidence * 0.7;
                
                const momentumConfidence = Math.abs(this.time_analysis.momentum_index - 0.5) * 20;
                baseConfidence += momentumConfidence;
                
                return [
                    Math.min(95, Math.max(50, baseConfidence)),
                    Math.min(90, Math.max(40, killConfidence)),
                    Math.min(95, ballConfidence)
                ];
            }
            
            // 生成精准的特码
            generatePreciseCodes(data, finalResult, predictedBalls) {
                if (data.length < 5) {
                    return [7, 11, 19, 23];
                }
                
                this.last_final_result = finalResult;
                
                const specialCodes = this.enhancedCodeAnalysis(data);
                
                this.algorithm_state.code_analysis_history.push({
                    'codes': [...specialCodes],
                    'timestamp': new Date(),
                    'data_size': data.length
                });
                
                if (this.algorithm_state.code_analysis_history.length > 50) {
                    this.algorithm_state.code_analysis_history.shift();
                }
                
                return specialCodes;
            }
            
            // 增强的特码分析算法
            enhancedCodeAnalysis(data) {
                if (data.length < 10) {
                    return [7, 11, 19, 23];
                }
                
                const recentCodes = data.slice(0, this.ai_parameters.code_analysis_depth).map(item => item.sum);
                
                const strongType = this.algorithm_state.strong_type || "大单";
                
                let predictedTypes = [];
                if (this.last_final_result) {
                    const finalResult = this.last_final_result;
                    for (let i = 0; i < finalResult.length; i += 2) {
                        predictedTypes.push(finalResult.substring(i, i + 2));
                    }
                } else {
                    predictedTypes = [strongType];
                    const otherTypes = ["大单", "大双", "小单", "小双"].filter(t => t !== strongType);
                    if (otherTypes.length > 0) {
                        predictedTypes.push(otherTypes[Math.floor(Math.random() * otherTypes.length)]);
                    }
                }
                
                const codeWeights = {};
                
                for (const [typeName, codes] of Object.entries(this.code_categories)) {
                    for (const code of codes) {
                        let weight = 1.0;
                        
                        weight *= (1 + this.trend_analysis.code_frequency[code] * 2);
                        
                        if (predictedTypes.includes(typeName)) {
                            weight *= 1.5;
                        }
                        
                        if (typeName === strongType) {
                            weight *= 1.3;
                        }
                        
                        if (recentCodes.includes(code)) {
                            const lastIndex = recentCodes.length - 1 - [...recentCodes].reverse().indexOf(code);
                            const omission = lastIndex;
                            weight *= (1 + omission / recentCodes.length * 0.5);
                        } else {
                            weight *= 1.2;
                        }
                        
                        codeWeights[code] = weight;
                    }
                }
                
                const finalCodes = [];
                
                for (const predType of predictedTypes) {
                    if (finalCodes.length >= 4) break;
                    
                    const typeCodes = [...this.code_categories[predType]];
                    typeCodes.sort((a, b) => (codeWeights[b] || 0) - (codeWeights[a] || 0));
                    
                    for (const code of typeCodes.slice(0, 2)) {
                        if (!finalCodes.includes(code) && finalCodes.length < 4) {
                            finalCodes.push(code);
                        }
                    }
                }
                
                if (finalCodes.length < 4) {
                    const allCodes = [];
                    for (const codes of Object.values(this.code_categories)) {
                        allCodes.push(...codes);
                    }
                    
                    allCodes.sort((a, b) => (codeWeights[b] || 0) - (codeWeights[a] || 0));
                    
                    for (const code of allCodes) {
                        if (!finalCodes.includes(code) && finalCodes.length < 4) {
                            finalCodes.push(code);
                        }
                    }
                }
                
                return finalCodes.slice(0, 4);
            }
            
            // 获取下一期期号的后两位
            getNextPeriodNumber(data) {
                if (!data || data.length === 0) {
                    return "00";
                }
                
                let latestPeriod;
                if (Array.isArray(data)) {
                    latestPeriod = data[0].period;
                } else {
                    latestPeriod = "000000";
                }
                
                const periodDigits = latestPeriod.replace(/\D/g, '');
                if (!periodDigits) {
                    return "00";
                }
                
                try {
                    let nextPeriod = parseInt(periodDigits) + 1;
                    const nextPeriodLastTwo = nextPeriod % 100;
                    return nextPeriodLastTwo.toString().padStart(2, '0');
                } catch (e) {
                    return "00";
                }
            }
            
            // 生成预测历史记录
            generatePredictionHistory(data) {
                if (data.length < 10) {
                    return [];
                }
                
                const history = [];
                const limit = Math.min(50, data.length - 1);
                
                for (let i = 0; i < limit; i++) {
                    const trainingData = data.slice(i + 1);
                    const testPeriod = data[i];
                    
                    const [finalResult, killResult, predictedBalls, ballConfidences] = this.sumBasedPrediction(trainingData);
                    
                    const predictedTypes = [];
                    for (let j = 0; j < finalResult.length; j += 2) {
                        predictedTypes.push(finalResult.substring(j, j + 2));
                    }
                    
                    let hitResult = "未中";
                    if (predictedTypes.includes(testPeriod.type)) {
                        hitResult = "中双组";
                    }
                    
                    const killHit = testPeriod.type !== killResult;
                    
                    history.push({
                        period: testPeriod.period,
                        timeStr: testPeriod.timeStr,
                        numbers: testPeriod.numbers,
                        sum: testPeriod.sum,
                        type: testPeriod.type,
                        killPrediction: killResult,
                        prediction: finalResult,
                        hit: hitResult,
                        killHit: killHit
                    });
                }
                
                return history;
            }
            
            // 计算准确率统计
            calculateAccuracyStats(history) {
                if (!history || history.length === 0) {
                    return {
                        total: 0,
                        hit: 0,
                        killHit: 0,
                        accuracy: 0,
                        killAccuracy: 0
                    };
                }
                
                const total = history.length;
                const hit = history.filter(item => item.hit === "中双组").length;
                const killHit = history.filter(item => item.killHit).length;
                const accuracy = total > 0 ? (hit / total) * 100 : 0;
                const killAccuracy = total > 0 ? (killHit / total) * 100 : 0;
                
                return {
                    total: total,
                    hit: hit,
                    killHit: killHit,
                    accuracy: Math.round(accuracy),
                    killAccuracy: Math.round(killAccuracy)
                };
            }
        }

        // 算法二预测器类
        class PC28PredictorV2 {
            constructor() {
                // 球预测参数
                this.ball_analysis = {
                    'ball_distributions': [new Array(10).fill(0), new Array(10).fill(0), new Array(10).fill(0)],
                    'ball_transitions': [
                        Array.from({length: 10}, () => new Array(10).fill(0)),
                        Array.from({length: 10}, () => new Array(10).fill(0)),
                        Array.from({length: 10}, () => new Array(10).fill(0))
                    ],
                    'ball_sequences': [[], [], []],
                    'type_history': [],
                    'kill_history': [],
                    'time_patterns': []
                };
                
                // 动态数据窗口
                this.data_window = [];
                
                // 时间分析参数
                this.time_analysis = {
                    'hourly_patterns': new Array(24).fill(0),
                    'daily_patterns': new Array(7).fill(0),
                    'recent_trends': [],
                    'volatility_index': 0.5,
                    'trend_strength': 0.5,
                    'momentum_index': 0.5
                };
                
                // 算法状态
                this.algorithm_state = {
                    'last_prediction': null,
                    'last_kill': null,
                    'prediction_count': {},
                    'kill_count': {},
                    'type_balance': {"大单": 0, "大双": 0, "小单": 0, "小双": 0},
                    'success_rate': 0.5,
                    'adaptation_factor': 1.0,
                    'pattern_memory': [],
                    'kill_algorithm_history': [],
                    'trend_memory': [],
                    'strong_type': null,
                    'ai_analysis_state': {}
                };
                
                // AI学习参数
                this.ai_parameters = {
                    'learning_rate': 0.1,
                    'exploration_rate': 0.15,
                    'pattern_threshold': 0.75,
                    'confidence_decay': 0.92,
                    'trend_sensitivity': 1.3,
                    'momentum_weight': 0.8
                };
                
                // 趋势分析参数
                this.trend_analysis = {
                    'short_term_trend': 0,
                    'medium_term_trend': 0,
                    'long_term_trend': 0,
                    'trend_consistency': 0.5,
                    'volatility_level': 0.5,
                    'pattern_recognition': {}
                };
                
                // 定义特码分类
                this.code_categories = {
                    "小单": [1, 3, 5, 7, 9, 11, 13],
                    "小双": [0, 2, 4, 6, 8, 10, 12],
                    "大单": [15, 17, 19, 21, 23, 25, 27],
                    "大双": [14, 16, 18, 20, 22, 24, 26]
                };
                
                // 预测历史记录
                this.prediction_history = [];
            }
            
            // 获取彩票数据
            async fetchLotteryData(limit = 100) {
                try {
                    const response = await fetch(`https://pc28.help/kj.json?limit=${limit}`);
                    const data = await response.json();
                    return data.data || [];
                } catch (error) {
                    console.error('获取开奖数据失败:', error);
                    // 返回模拟数据作为备用
                    return this.generateMockData(limit);
                }
            }
            
            // 生成模拟数据（备用）
            generateMockData(limit) {
                const mockData = [];
                let period = 3361000;
                
                for (let i = 0; i < limit; i++) {
                    const num1 = Math.floor(Math.random() * 10);
                    const num2 = Math.floor(Math.random() * 10);
                    const num3 = Math.floor(Math.random() * 10);
                    const sum = num1 + num2 + num3;
                    
                    let type;
                    if (sum <= 13) {
                        type = (sum % 2 === 0) ? "小双" : "小单";
                    } else {
                        type = (sum % 2 === 0) ? "大双" : "大单";
                    }
                    
                    mockData.push({
                        qihao: (period + i).toString(),
                        opennum: `${num1},${num2},${num3}`,
                        opentime: new Date(Date.now() - i * 5 * 60 * 1000).toISOString().replace('T', ' ').substring(0, 19)
                    });
                }
                
                return mockData;
            }
            
            // 解析网络开奖数据
            parseNetworkData(rawData) {
                const periods = [];
                
                for (const item of rawData) {
                    try {
                        const numbersStr = item.opennum || '';
                        const numbers = numbersStr.includes(',') ? 
                            numbersStr.split(',') : numbersStr.split('+');
                        const [num1, num2, num3] = numbers.map(Number);
                        const sumVal = num1 + num2 + num3;
                        
                        let lotteryType;
                        if (sumVal <= 13) {
                            lotteryType = (sumVal % 2 === 0) ? "小双" : "小单";
                        } else {
                            lotteryType = (sumVal % 2 === 0) ? "大双" : "大单";
                        }
                        
                        // 解析时间
                        const openTime = item.opentime || '';
                        let hour, weekday, timeStr;
                        
                        if (openTime) {
                            try {
                                const timeObj = new Date(openTime.replace(' ', 'T'));
                                hour = timeObj.getHours();
                                weekday = timeObj.getDay();
                                // 提取时间部分 (HH:MM)
                                timeStr = openTime.split(' ')[1] ? openTime.split(' ')[1].substring(0, 5) : '00:00';
                            } catch (e) {
                                hour = Math.floor(Math.random() * 24);
                                weekday = Math.floor(Math.random() * 7);
                                timeStr = '00:00';
                            }
                        } else {
                            hour = Math.floor(Math.random() * 24);
                            weekday = Math.floor(Math.random() * 7);
                            timeStr = '00:00';
                        }
                        
                        periods.push({
                            'period': item.qihao || '',
                            'numbers': [num1, num2, num3],
                            'sum': sumVal,
                            'type': lotteryType,
                            'time': openTime,
                            'timeStr': timeStr,
                            'hour': hour,
                            'weekday': weekday
                        });
                    } catch (error) {
                        console.error('解析数据出错:', error);
                        continue;
                    }
                }
                
                return periods;
            }
            
            // 分析动态走势
            analyzeDynamicTrends(data) {
                if (data.length < 10) return;
                
                // 提取和值序列
                const sums = data.map(item => item.sum);
                const types = data.map(item => item.type);
                
                // 计算不同时间尺度的趋势
                if (sums.length >= 5) {
                    this.trend_analysis.short_term_trend = this.calculateTrendDirection(sums.slice(0, 5));
                }
                
                if (sums.length >= 10) {
                    this.trend_analysis.medium_term_trend = this.calculateTrendDirection(sums.slice(0, 10));
                }
                
                if (sums.length >= 20) {
                    this.trend_analysis.long_term_trend = this.calculateTrendDirection(sums.slice(0, 20));
                }
                
                // 计算趋势一致性
                this.calculateTrendConsistency(sums);
                
                // 计算波动水平
                this.calculateVolatilityLevel(sums);
                
                // 识别模式
                this.identifyPatterns(types, sums);
                
                // 计算动量指数
                this.calculateMomentumIndex(data);
            }
            
            // 计算趋势方向
            calculateTrendDirection(dataSeries) {
                if (dataSeries.length < 3) return 0;
                
                const x = Array.from({length: dataSeries.length}, (_, i) => i);
                const y = dataSeries;
                
                // 简单线性回归计算斜率
                const n = x.length;
                const sumX = x.reduce((a, b) => a + b, 0);
                const sumY = y.reduce((a, b) => a + b, 0);
                const sumXY = x.reduce((sum, val, i) => sum + val * y[i], 0);
                const sumX2 = x.reduce((sum, val) => sum + val * val, 0);
                
                const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
                
                // 归一化斜率
                return Math.tanh(slope / 5.0);
            }
            
            // 计算趋势一致性
            calculateTrendConsistency(sums) {
                if (sums.length < 5) {
                    this.trend_analysis.trend_consistency = 0.5;
                    return;
                }
                
                const windows = [5, 8, 12];
                const consistencies = [];
                
                for (const window of windows) {
                    if (sums.length >= window) {
                        const windowSums = sums.slice(0, window);
                        const trendDirections = [];
                        
                        for (let i = 1; i < windowSums.length; i++) {
                            const direction = windowSums[i] > windowSums[i-1] ? 1 : 
                                            (windowSums[i] < windowSums[i-1] ? -1 : 0);
                            trendDirections.push(direction);
                        }
                        
                        if (trendDirections.length > 0) {
                            const consistency = trendDirections.filter(d => d === trendDirections[0]).length / trendDirections.length;
                            consistencies.push(consistency);
                        }
                    }
                }
                
                if (consistencies.length > 0) {
                    this.trend_analysis.trend_consistency = consistencies.reduce((a, b) => a + b, 0) / consistencies.length;
                } else {
                    this.trend_analysis.trend_consistency = 0.5;
                }
            }
            
            // 计算波动水平
            calculateVolatilityLevel(sums) {
                if (sums.length < 5) {
                    this.trend_analysis.volatility_level = 0.5;
                    return;
                }
                
                const windowSums = sums.slice(0, 15);
                const mean = windowSums.reduce((a, b) => a + b, 0) / windowSums.length;
                const variance = windowSums.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / windowSums.length;
                const stdDev = Math.sqrt(variance);
                
                const volatility = stdDev / mean;
                const normalizedVolatility = Math.min(1.0, volatility * 3);
                this.trend_analysis.volatility_level = normalizedVolatility;
            }
            
            // 识别模式
            identifyPatterns(types, sums) {
                if (types.length < 8) return;
                
                const typePatterns = {};
                
                for (let i = 0; i < types.length - 3; i++) {
                    const pattern = types.slice(i, i + 3);
                    const nextType = types[i + 3];
                    
                    const patternKey = pattern.join(',');
                    
                    if (!typePatterns[patternKey]) {
                        typePatterns[patternKey] = [];
                    }
                    
                    if (nextType) {
                        typePatterns[patternKey].push(nextType);
                    }
                }
                
                const patternAccuracy = {};
                for (const [pattern, outcomes] of Object.entries(typePatterns)) {
                    if (outcomes.length >= 2) {
                        const counter = {};
                        for (const outcome of outcomes) {
                            counter[outcome] = (counter[outcome] || 0) + 1;
                        }
                        
                        let mostCommon = null;
                        let maxCount = 0;
                        
                        for (const [type, count] of Object.entries(counter)) {
                            if (count > maxCount) {
                                mostCommon = type;
                                maxCount = count;
                            }
                        }
                        
                        const accuracy = maxCount / outcomes.length;
                        patternAccuracy[pattern] = [mostCommon, accuracy];
                    }
                }
                
                this.trend_analysis.pattern_recognition = patternAccuracy;
            }
            
            // 计算动量指数
            calculateMomentumIndex(data) {
                if (data.length < 8) {
                    this.time_analysis.momentum_index = 0.5;
                    return;
                }
                
                const sums = data.slice(0, 15).map(item => item.sum);
                const momentumIndicators = [];
                
                if (sums.length >= 4) {
                    const shortMomentum = (sums[0] - sums[3]) / 3.0;
                    momentumIndicators.push(shortMomentum);
                }
                
                if (sums.length >= 7) {
                    const mediumMomentum = (sums[0] - sums[6]) / 6.0;
                    momentumIndicators.push(mediumMomentum);
                }
                
                if (sums.length >= 11) {
                    const longMomentum = (sums[0] - sums[10]) / 10.0;
                    momentumIndicators.push(longMomentum);
                }
                
                if (momentumIndicators.length > 0) {
                    const avgMomentum = momentumIndicators.reduce((a, b) => a + b, 0) / momentumIndicators.length;
                    const normalizedMomentum = Math.tanh(avgMomentum / 5.0) * 0.5 + 0.5;
                    this.time_analysis.momentum_index = normalizedMomentum;
                } else {
                    this.time_analysis.momentum_index = 0.5;
                }
            }
            
            // 增强杀组算法
            enhancedKillAlgorithm(data) {
                if (data.length < 3) {
                    return [null, 0];
                }
                
                try {
                    // 获取前三期数据
                    const prev1 = data[0];  // 前1期（最新）
                    const prev2 = data[1];  // 前2期
                    const prev3 = data[2];  // 前3期
                    
                    // 计算参数
                    const A = prev3.sum % 10;  // 前3期和值的个位
                    const B = [...prev2.numbers].sort((a, b) => a - b)[1];  // 前2期三个数字的中间数字
                    const C = prev1.sum % 10;  // 前1期和值的个位
                    
                    // 计算S值
                    let S = (A + B + C + 8) * 3;
                    
                    // 调整S值到0-27范围内
                    while (S > 28) {
                        S = S - 28;
                    }
                    
                    // 将S转换为类型
                    const killType = this.sumToType(S);
                    
                    // 计算置信度
                    const confidence = this.calculateKillAlgorithmConfidence(data, A, B, C, S);
                    
                    // 记录算法使用历史
                    this.algorithm_state.kill_algorithm_history.push({
                        A: A, B: B, C: C, S: S, kill_type: killType,
                        confidence: confidence, timestamp: new Date()
                    });
                    
                    // 保持历史记录长度
                    if (this.algorithm_state.kill_algorithm_history.length > 25) {
                        this.algorithm_state.kill_algorithm_history.shift();
                    }
                    
                    return [killType, confidence];
                    
                } catch (error) {
                    console.error('杀组算法计算错误:', error);
                    return [null, 0];
                }
            }
            
            // 计算杀组算法的置信度
            calculateKillAlgorithmConfidence(data, A, B, C, S) {
                if (data.length < 10) {
                    return 60;
                }
                
                let baseConfidence = 65;
                
                // 历史准确率分析
                const history = this.algorithm_state.kill_algorithm_history;
                if (history.length >= 5) {
                    // 计算最近5次的平均置信度
                    const recentConfidences = history.slice(-5).map(h => h.confidence);
                    const avgConfidence = recentConfidences.reduce((a, b) => a + b, 0) / recentConfidences.length;
                    baseConfidence = (baseConfidence + avgConfidence) / 2;
                }
                
                // 参数稳定性分析
                const recentSValues = history.slice(-5).map(h => h.S);
                const SStd = recentSValues.length > 1 ? 
                    Math.sqrt(recentSValues.reduce((sum, val) => sum + Math.pow(val - S, 2), 0) / recentSValues.length) : 0;
                if (SStd < 5) {  // S值稳定性高，置信度提高
                    baseConfidence += 10;
                }
                
                // 数据量影响
                if (data.length >= 50) {
                    baseConfidence += 10;
                } else if (data.length >= 30) {
                    baseConfidence += 5;
                }
                
                // 趋势一致性
                if (history.length >= 3) {
                    const recentKills = history.slice(-3).map(h => h.kill_type);
                    if (new Set(recentKills).size === 1) {  // 连续相同杀组
                        baseConfidence += 5;
                    }
                }
                
                return Math.min(85, Math.max(40, baseConfidence));
            }
            
            // 分析时间模式
            analyzeTimePatterns(data) {
                if (data.length < 10) return;
                
                // 分析小时模式
                const hourlyCounts = new Array(24).fill(0);
                for (const item of data) {
                    hourlyCounts[item.hour]++;
                }
                
                const totalHours = data.length;
                if (totalHours > 0) {
                    this.time_analysis.hourly_patterns = hourlyCounts.map(count => count / totalHours);
                }
                
                // 分析星期模式
                const dailyCounts = new Array(7).fill(0);
                for (const item of data) {
                    dailyCounts[item.weekday]++;
                }
                
                const totalDays = data.length;
                if (totalDays > 0) {
                    this.time_analysis.daily_patterns = dailyCounts.map(count => count / totalDays);
                }
                
                // 分析近期趋势
                const recentSums = data.slice(0, 10).map(item => item.sum);
                if (recentSums.length >= 5) {
                    // 计算趋势强度
                    const trendValues = [];
                    for (let i = 1; i < recentSums.length; i++) {
                        trendValues.push(recentSums[i] - recentSums[i-1]);
                    }
                    
                    if (trendValues.length > 0) {
                        const avgTrend = trendValues.reduce((a, b) => a + b, 0) / trendValues.length;
                        const trendStrength = Math.min(1.0, Math.abs(avgTrend) / 5.0);
                        this.time_analysis.trend_strength = trendStrength;
                    }
                }
            }
            
            // 分析类型模式
            analyzeTypePatterns(data) {
                if (data.length < 10) return;
                
                // 分析近期类型分布
                const recentTypes = data.slice(0, 20).map(item => item.type);
                const typeCounter = {};
                
                for (const type of recentTypes) {
                    typeCounter[type] = (typeCounter[type] || 0) + 1;
                }
                
                const total = recentTypes.length;
                
                // 更新类型平衡状态
                for (const typeName of ["大单", "大双", "小单", "小双"]) {
                    const count = typeCounter[typeName] || 0;
                    this.algorithm_state.type_balance[typeName] = total > 0 ? count / total : 0.25;
                }
            }
            
            // 自适应学习算法
            adaptiveLearning(data, predictionAccuracy) {
                // 更新成功率
                this.algorithm_state.success_rate = 
                    this.algorithm_state.success_rate * 0.9 + predictionAccuracy * 0.1;
                
                // 根据成功率调整适应因子
                if (predictionAccuracy > 0.6) {
                    // 成功率高，增加探索性
                    this.algorithm_state.adaptation_factor *= 1.05;
                } else {
                    // 成功率低，增加保守性
                    this.algorithm_state.adaptation_factor *= 0.95;
                }
                
                // 限制适应因子范围
                this.algorithm_state.adaptation_factor = Math.max(0.5, Math.min(2.0, this.algorithm_state.adaptation_factor));
                
                // 学习模式记忆
                if (data.length >= 5) {
                    const recentPattern = data.slice(0, 5).map(item => item.type);
                    this.algorithm_state.pattern_memory.push(recentPattern);
                    
                    if (this.algorithm_state.pattern_memory.length > 15) {
                        this.algorithm_state.pattern_memory.shift();
                    }
                }
            }
            
            // 增强的球预测算法
            predictBallsEnhanced(data) {
                if (data.length < 5) {
                    const randomBalls = [
                        Math.floor(Math.random() * 10),
                        Math.floor(Math.random() * 10),
                        Math.floor(Math.random() * 10)
                    ];
                    return [randomBalls, [50, 50, 50]];
                }
                
                this.analyzeTypePatterns(data);
                this.analyzeTimePatterns(data);
                this.analyzeDynamicTrends(data);
                
                const currentBalls = data[0].numbers;
                const predictedBalls = [];
                const confidenceScores = [];
                
                for (let ballIdx = 0; ballIdx < 3; ballIdx++) {
                    const predictions = [];
                    const weights = [];
                    const methodScores = [];
                    
                    // 1. 基于转移矩阵
                    const [transPred, transScore] = this.predictByTransition(ballIdx, currentBalls[ballIdx]);
                    predictions.push(transPred);
                    weights.push(1.2 * this.algorithm_state.adaptation_factor);
                    methodScores.push(transScore);
                    
                    // 2. 基于近期趋势
                    const [trendPred, trendScore] = this.predictByTrend(ballIdx, data);
                    predictions.push(trendPred);
                    weights.push(1.1 * this.time_analysis.trend_strength);
                    methodScores.push(trendScore);
                    
                    // 3. 基于序列模式
                    const [seqPred, seqScore] = this.predictBySequence(ballIdx);
                    predictions.push(seqPred);
                    weights.push(1.0);
                    methodScores.push(seqScore);
                    
                    // 4. 基于分布
                    const [distPred, distScore] = this.predictByDistribution(ballIdx);
                    predictions.push(distPred);
                    weights.push(0.9);
                    methodScores.push(distScore);
                    
                    // 5. 基于相关性
                    const [corrPred, corrScore] = this.predictByCorrelation(ballIdx, currentBalls);
                    predictions.push(corrPred);
                    weights.push(0.8);
                    methodScores.push(corrScore);
                    
                    // 6. 基于时间模式
                    const [timePred, timeScore] = this.predictByTimePattern(ballIdx, data);
                    predictions.push(timePred);
                    weights.push(0.7 * (1 + this.time_analysis.volatility_index));
                    methodScores.push(timeScore);
                    
                    // 7. 基于动态趋势
                    const [trendBasedPred, trendScore2] = this.predictByDynamicTrend(ballIdx, data);
                    predictions.push(trendBasedPred);
                    weights.push(0.8 * (1 + Math.abs(this.trend_analysis.short_term_trend)));
                    methodScores.push(trendScore2);
                    
                    // 加权投票
                    const ballScores = new Array(10).fill(0);
                    
                    for (let i = 0; i < predictions.length; i++) {
                        const pred = predictions[i];
                        const weight = weights[i];
                        const score = methodScores[i];
                        
                        ballScores[pred] += weight * score;
                    }
                    
                    // 避免重复模式
                    if (this.algorithm_state.last_prediction) {
                        const lastBalls = this.algorithm_state.last_prediction;
                        if (ballScores[lastBalls[ballIdx]] > 0) {
                            ballScores[lastBalls[ballIdx]] *= 0.7;
                        }
                    }
                    
                    // 考虑时间因素调整
                    const currentHour = data[0].hour;
                    const hourWeight = this.time_analysis.hourly_patterns[currentHour];
                    if (hourWeight > 0.05) {  // 如果该小时有显著模式
                        for (let i = 0; i < 10; i++) {
                            ballScores[i] *= (1 + hourWeight * 0.3);
                        }
                    }
                    
                    // 考虑动量因素
                    const momentumFactor = 1.0 + (this.time_analysis.momentum_index - 0.5) * 0.4;
                    for (let i = 0; i < 10; i++) {
                        ballScores[i] *= momentumFactor;
                    }
                    
                    let bestBall = 0;
                    let maxScore = ballScores[0];
                    
                    for (let i = 1; i < 10; i++) {
                        if (ballScores[i] > maxScore) {
                            maxScore = ballScores[i];
                            bestBall = i;
                        }
                    }
                    
                    const confidence = Math.min(95, maxScore / weights.reduce((a, b) => a + b, 0) * 100);
                    
                    predictedBalls.push(bestBall);
                    confidenceScores.push(confidence);
                }
                
                return [predictedBalls, confidenceScores];
            }
            
            // 基于动态趋势预测
            predictByDynamicTrend(ballIdx, data) {
                if (data.length < 8) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                // 获取该球的历史数据
                const ballHistory = data.slice(0, 15).map(item => item.numbers[ballIdx]);
                
                // 计算趋势方向
                const trendDirection = this.trend_analysis.short_term_trend;
                
                // 根据趋势方向调整预测
                const currentValue = ballHistory[0];
                
                if (Math.abs(trendDirection) > 0.1) {  // 有明显趋势
                    const adjustment = Math.round(trendDirection * 3);  // 根据趋势强度调整
                    let predicted = currentValue + adjustment;
                    predicted = Math.max(0, Math.min(9, predicted));
                    
                    // 置信度基于趋势强度和一致性
                    const confidence = 0.5 + Math.abs(trendDirection) * 0.3 + this.trend_analysis.trend_consistency * 0.2;
                    return [predicted, Math.min(0.8, confidence)];
                } else {
                    // 无明显趋势，使用加权平均
                    const weights = ballHistory.map((_, i) => Math.exp(-i * 0.2));
                    const weightSum = weights.reduce((a, b) => a + b, 0);
                    const normalizedWeights = weights.map(w => w / weightSum);
                    
                    const weightedAvg = ballHistory.reduce((sum, val, i) => sum + val * normalizedWeights[i], 0);
                    return [Math.round(weightedAvg), 0.6];
                }
            }
            
            // 基于转移矩阵预测
            predictByTransition(ballIdx, currentBall) {
                if (currentBall < 0 || currentBall > 9) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const transitionProbs = this.ball_analysis.ball_transitions[ballIdx][currentBall];
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                
                const combinedProbs = transitionProbs.map((prob, i) => prob * (distribution[i] + 0.01));
                
                let bestBall = 0;
                let maxProb = combinedProbs[0];
                
                for (let i = 1; i < 10; i++) {
                    if (combinedProbs[i] > maxProb) {
                        maxProb = combinedProbs[i];
                        bestBall = i;
                    }
                }
                
                const confidence = Math.min(0.9, maxProb / combinedProbs.reduce((a, b) => a + b, 0) * 2);
                
                return [bestBall, confidence];
            }
            
            // 基于趋势预测
            predictByTrend(ballIdx, data) {
                if (data.length < 3) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const recentBalls = data.slice(0, 8).map(item => item.numbers[ballIdx]);
                
                if (recentBalls.length >= 3) {
                    // 使用加权移动平均
                    const weights = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8].slice(0, recentBalls.length);
                    const weightSum = weights.reduce((a, b) => a + b, 0);
                    const normalizedWeights = weights.map(w => w / weightSum);
                    
                    const weightedAvg = recentBalls.reduce((sum, val, i) => sum + val * normalizedWeights[i], 0);
                    
                    // 计算趋势方向
                    if (recentBalls.length >= 5) {
                        const shortAvg = recentBalls.slice(0, 3).reduce((sum, val, i) => sum + val * normalizedWeights[i], 0) / 
                                       normalizedWeights.slice(0, 3).reduce((a, b) => a + b, 0);
                        const longAvg = weightedAvg;
                        
                        const trendDirection = shortAvg > longAvg ? 1 : -1;
                        const trendStrength = Math.min(1.0, Math.abs(shortAvg - longAvg) / 3.0);
                        
                        const adjustment = trendDirection * trendStrength * 2;
                        let predicted = Math.round(weightedAvg + adjustment);
                        predicted = Math.max(0, Math.min(9, predicted));
                        
                        const confidence = 0.5 + trendStrength * 0.3;
                        
                        return [predicted, confidence];
                    }
                }
                
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                let bestBall = 0;
                let maxProb = distribution[0];
                
                for (let i = 1; i < 10; i++) {
                    if (distribution[i] > maxProb) {
                        maxProb = distribution[i];
                        bestBall = i;
                    }
                }
                
                return [bestBall, 0.6];
            }
            
            // 基于序列模式预测
            predictBySequence(ballIdx) {
                const sequence = this.ball_analysis.ball_sequences[ballIdx];
                if (sequence.length < 3) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const recent = sequence.slice(-5);
                
                // 检测重复模式
                if (new Set(recent).size === 1) {
                    return [(recent[0] + 1) % 10, 0.7];
                }
                
                // 检测上升/下降模式
                if (recent.every((val, i, arr) => i === 0 || val > arr[i-1])) {
                    const predicted = Math.min(9, recent[recent.length-1] + 1);
                    return [predicted, 0.65];
                } else if (recent.every((val, i, arr) => i === 0 || val < arr[i-1])) {
                    const predicted = Math.max(0, recent[recent.length-1] - 1);
                    return [predicted, 0.65];
                }
                
                // 检测周期性
                if (sequence.length >= 6) {
                    const pattern = sequence.slice(-6, -3);
                    const current = sequence.slice(-3);
                    if (JSON.stringify(pattern) === JSON.stringify(current)) {
                        // 周期性重复
                        const nextVal = sequence.length >= 7 ? sequence[sequence.length-7] : (sequence[sequence.length-4] + 1) % 10;
                        return [nextVal, 0.7];
                    }
                }
                
                // 随机波动，使用加权平均
                const weights = [0.05, 0.1, 0.15, 0.3, 0.4].slice(0, recent.length);
                const weightSum = weights.reduce((a, b) => a + b, 0);
                const normalizedWeights = weights.map(w => w / weightSum);
                const weightedAvg = recent.reduce((sum, val, i) => sum + val * normalizedWeights[i], 0);
                
                return [Math.round(weightedAvg), 0.6];
            }
            
            // 基于分布预测
            predictByDistribution(ballIdx) {
                const distribution = this.ball_analysis.ball_distributions[ballIdx];
                
                // 如果分布太均匀，添加一些随机性
                if (Math.max(...distribution) - Math.min(...distribution) < 0.1) {
                    const sequence = this.ball_analysis.ball_sequences[ballIdx];
                    if (sequence.length >= 3) {
                        const recentCounter = {};
                        for (const ball of sequence.slice(-8)) {
                            recentCounter[ball] = (recentCounter[ball] || 0) + 1;
                        }
                        
                        if (Object.keys(recentCounter).length > 0) {
                            // 结合近期热点
                            let hotBall = 0;
                            let maxCount = 0;
                            
                            for (const [ball, count] of Object.entries(recentCounter)) {
                                if (count > maxCount) {
                                    maxCount = count;
                                    hotBall = parseInt(ball);
                                }
                            }
                            
                            return [hotBall, 0.55];
                        }
                    }
                }
                
                let bestBall = 0;
                let maxProb = distribution[0];
                
                for (let i = 1; i < 10; i++) {
                    if (distribution[i] > maxProb) {
                        maxProb = distribution[i];
                        bestBall = i;
                    }
                }
                
                const confidence = Math.min(0.8, maxProb * 1.5);
                
                return [bestBall, confidence];
            }
            
            // 基于相关性预测
            predictByCorrelation(ballIdx, currentBalls) {
                // 简单实现：如果其他球有显著趋势，跟随趋势
                let refBalls;
                if (ballIdx === 0) {
                    // A球参考B和C
                    refBalls = [currentBalls[1], currentBalls[2]];
                } else if (ballIdx === 1) {
                    // B球参考A和C
                    refBalls = [currentBalls[0], currentBalls[2]];
                } else {
                    // C球参考A和B
                    refBalls = [currentBalls[0], currentBalls[1]];
                }
                
                const avgRef = refBalls.reduce((a, b) => a + b, 0) / refBalls.length;
                
                // 计算相关性强度
                const refStd = Math.sqrt(refBalls.reduce((sum, val) => sum + Math.pow(val - avgRef, 2), 0) / refBalls.length);
                const correlationStrength = 1.0 - (refStd / 5.0 || 0.5);
                
                return [Math.round(avgRef), 0.4 + correlationStrength * 0.3];
            }
            
            // 基于时间模式预测
            predictByTimePattern(ballIdx, data) {
                if (data.length < 10) {
                    return [Math.floor(Math.random() * 10), 0.5];
                }
                
                const currentHour = data[0].hour;
                const currentWeekday = data[0].weekday;
                
                // 分析该小时的历史模式
                const hourData = data.filter(item => item.hour === currentHour);
                if (hourData.length >= 3) {
                    const hourBalls = hourData.slice(0, 5).map(item => item.numbers[ballIdx]);
                    const hourAvg = hourBalls.reduce((a, b) => a + b, 0) / hourBalls.length;
                    const predicted = Math.round(hourAvg);
                    const confidence = Math.min(0.7, hourData.length / 10.0);
                    return [predicted, confidence];
                }
                
                // 分析该星期的历史模式
                const weekdayData = data.filter(item => item.weekday === currentWeekday);
                if (weekdayData.length >= 3) {
                    const weekdayBalls = weekdayData.slice(0, 5).map(item => item.numbers[ballIdx]);
                    const weekdayAvg = weekdayBalls.reduce((a, b) => a + b, 0) / weekdayBalls.length;
                    const predicted = Math.round(weekdayAvg);
                    const confidence = Math.min(0.6, weekdayData.length / 10.0);
                    return [predicted, confidence];
                }
                
                return [Math.floor(Math.random() * 10), 0.5];
            }
            
            // 更新球分析数据
            updateBallAnalysis(data) {
                if (data.length < 2) return;
                
                for (let i = 0; i < 3; i++) {
                    this.ball_analysis.ball_distributions[i] = new Array(10).fill(0);
                }
                
                // 使用时间加权更新分布
                const timeWeights = Array.from({length: Math.min(80, data.length)}, (_, i) => Math.exp(-i * 0.1));
                const weightSum = timeWeights.reduce((a, b) => a + b, 0);
                const normalizedWeights = timeWeights.map(w => w / weightSum);
                
                for (let idx = 0; idx < Math.min(80, data.length); idx++) {
                    const numbers = data[idx].numbers;
                    const weight = idx < normalizedWeights.length ? normalizedWeights[idx] : 1.0;
                    
                    for (let i = 0; i < 3; i++) {
                        if (numbers[i] >= 0 && numbers[i] <= 9) {
                            this.ball_analysis.ball_distributions[i][numbers[i]] += weight;
                            this.ball_analysis.ball_sequences[i].push(numbers[i]);
                            
                            // 保持序列长度
                            if (this.ball_analysis.ball_sequences[i].length > 25) {
                                this.ball_analysis.ball_sequences[i].shift();
                            }
                        }
                    }
                }
                
                for (let i = 0; i < 3; i++) {
                    const total = this.ball_analysis.ball_distributions[i].reduce((a, b) => a + b, 0);
                    if (total > 0) {
                        this.ball_analysis.ball_distributions[i] = this.ball_analysis.ball_distributions[i].map(val => val / total);
                    }
                }
                
                // 更新转移矩阵（带时间权重）
                for (let ballIdx = 0; ballIdx < 3; ballIdx++) {
                    this.ball_analysis.ball_transitions[ballIdx] = Array.from({length: 10}, () => new Array(10).fill(0));
                    
                    for (let i = 0; i < Math.min(data.length - 1, 50); i++) {
                        const fromBall = data[i].numbers[ballIdx];
                        const toBall = data[i + 1].numbers[ballIdx];
                        const weight = i < normalizedWeights.length ? normalizedWeights[i] : 1.0;
                        
                        if (fromBall >= 0 && fromBall <= 9 && toBall >= 0 && toBall <= 9) {
                            this.ball_analysis.ball_transitions[ballIdx][fromBall][toBall] += weight;
                        }
                    }
                    
                    // 归一化转移矩阵
                    for (let from = 0; from < 10; from++) {
                        const rowSum = this.ball_analysis.ball_transitions[ballIdx][from].reduce((a, b) => a + b, 0);
                        if (rowSum > 0) {
                            for (let to = 0; to < 10; to++) {
                                this.ball_analysis.ball_transitions[ballIdx][from][to] /= rowSum;
                            }
                        }
                    }
                }
            }
            
            // 同时分析AI状态和杀组推荐，确保结果一致且以强势为主
            analyzeAIStateAndKill(data, predictedBalls) {
                if (data.length < 10) {
                    return ["大单大双", "大双"];
                }
                
                // 分析动态走势
                this.analyzeDynamicTrends(data);
                
                // 获取预测和值
                const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
                const predictedType = this.sumToType(predictedSum);
                
                // 计算强势类型
                const strongType = this.calculateStrongType(data);
                this.algorithm_state.strong_type = strongType;
                
                // 更新AI分析状态
                this.updateAIAnalysisState(data, strongType);
                
                // 生成双组预测（基于强势类型）
                const finalTypes = this.generateDoublePredictionBasedOnStrongType(data, strongType);
                
                // 选择杀组（确保与AI分析状态一致）
                const killType = this.selectKillBasedOnAIState(finalTypes, predictedType, data, strongType);
                
                return [finalTypes.join(''), killType];
            }
            
            // 计算强势类型
            calculateStrongType(data) {
                if (data.length < 10) return "大单";
                
                // 多种方法计算强势类型
                const typeScores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                // 1. 基于趋势分析
                const trendScore = this.calculateTrendBasedScore(data);
                for (const [typeName, score] of Object.entries(trendScore)) {
                    typeScores[typeName] += score * 0.3;
                }
                
                // 2. 基于动量分析
                const momentumScore = this.calculateMomentumBasedScore(data);
                for (const [typeName, score] of Object.entries(momentumScore)) {
                    typeScores[typeName] += score * 0.25;
                }
                
                // 3. 基于模式识别
                const patternScore = this.calculatePatternBasedScore(data);
                for (const [typeName, score] of Object.entries(patternScore)) {
                    typeScores[typeName] += score * 0.2;
                }
                
                // 4. 基于遗漏分析
                const omissionScore = this.calculateOmissionBasedScore(data);
                for (const [typeName, score] of Object.entries(omissionScore)) {
                    typeScores[typeName] += score * 0.15;
                }
                
                // 5. 基于时间模式
                const timeScore = this.calculateTimeBasedScore(data);
                for (const [typeName, score] of Object.entries(timeScore)) {
                    typeScores[typeName] += score * 0.1;
                }
                
                // 返回分数最高的类型
                let maxType = "大单";
                let maxScore = typeScores["大单"];
                
                for (const [typeName, score] of Object.entries(typeScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        maxType = typeName;
                    }
                }
                
                return maxType;
            }
            
            // 基于趋势分析的分数计算
            calculateTrendBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                // 获取趋势信息
                const shortTrend = this.trend_analysis.short_term_trend;
                const trendConsistency = this.trend_analysis.trend_consistency;
                
                if (Math.abs(shortTrend) > 0.1 && trendConsistency > 0.6) {
                    // 有明显趋势且一致性高
                    const currentSum = data[0].sum;
                    
                    if (shortTrend > 0) {  // 上升趋势
                        if (currentSum <= 13) {
                            // 从小数上升，预测大数
                            scores["大单"] = 0.8;
                            scores["大双"] = 0.7;
                        } else {
                            // 从大数继续上升，预测大数
                            scores["大单"] = 0.9;
                            scores["大双"] = 0.8;
                        }
                    } else {  // 下降趋势
                        if (currentSum >= 14) {
                            // 从大数下降，预测小数
                            scores["小单"] = 0.8;
                            scores["小双"] = 0.7;
                        } else {
                            // 从小数继续下降，预测小数
                            scores["小单"] = 0.9;
                            scores["小双"] = 0.8;
                        }
                    }
                } else {
                    // 无明显趋势，平均分配
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于动量分析的分数计算
            calculateMomentumBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const momentum = this.time_analysis.momentum_index;
                
                if (momentum > 0.7) {  // 强动量
                    // 强动量下，延续当前类型
                    const currentType = data[0].type;
                    scores[currentType] = 0.9;
                    
                    // 对相反类型给予低分
                    const oppositeTypes = this.getOppositeTypes(currentType);
                    for (const oppType of oppositeTypes) {
                        scores[oppType] = 0.2;
                    }
                } else if (momentum < 0.3) {  // 弱动量
                    // 弱动量下，倾向于变化
                    const currentType = data[0].type;
                    scores[currentType] = 0.3;
                    
                    // 对其他类型给予较高分
                    for (const typeName of Object.keys(scores)) {
                        if (typeName !== currentType) {
                            scores[typeName] = 0.7;
                        }
                    }
                } else {
                    // 中等动量，平均分配
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于模式识别的分数计算
            calculatePatternBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const recentTypes = data.slice(0, 5).map(item => item.type);
                
                // 检查是否有已知模式
                const pattern = recentTypes.join(',');
                if (this.trend_analysis.pattern_recognition[pattern]) {
                    const [nextType, accuracy] = this.trend_analysis.pattern_recognition[pattern];
                    if (accuracy > 0.6) {  // 模式准确率高于60%
                        scores[nextType] = accuracy;
                    } else {
                        // 模式准确率低，平均分配
                        for (const typeName of Object.keys(scores)) {
                            scores[typeName] = 0.5;
                        }
                    }
                } else {
                    // 无有效模式，平均分配
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.5;
                    }
                }
                
                return scores;
            }
            
            // 基于遗漏分析的分数计算
            calculateOmissionBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                // 计算各类型的遗漏值
                const recentTypes = data.slice(0, 20).map(item => item.type);
                const allTypes = ["大单", "大双", "小单", "小双"];
                
                const omissions = {};
                for (const typeName of allTypes) {
                    // 找到该类型最近一次出现的位置
                    if (recentTypes.includes(typeName)) {
                        const lastIndex = recentTypes.length - 1 - [...recentTypes].reverse().indexOf(typeName);
                        omissions[typeName] = lastIndex;
                    } else {
                        omissions[typeName] = recentTypes.length;  // 从未出现
                    }
                }
                
                // 根据遗漏值分配分数（遗漏越久，分数越高）
                const maxOmission = Math.max(...Object.values(omissions));
                for (const [typeName, omission] of Object.entries(omissions)) {
                    const omissionFactor = omission / maxOmission;
                    scores[typeName] = omissionFactor;
                }
                
                return scores;
            }
            
            // 基于时间模式的分数计算
            calculateTimeBasedScore(data) {
                const scores = {"大单": 0, "大双": 0, "小单": 0, "小双": 0};
                
                const currentHour = data[0].hour;
                
                // 分析该小时的历史模式
                const hourData = data.filter(item => item.hour === currentHour);
                if (hourData.length >= 3) {
                    const hourTypes = hourData.map(item => item.type);
                    const typeCounter = {};
                    
                    for (const type of hourTypes) {
                        typeCounter[type] = (typeCounter[type] || 0) + 1;
                    }
                    
                    const total = hourTypes.length;
                    
                    for (const [typeName, count] of Object.entries(typeCounter)) {
                        scores[typeName] = count / total;
                    }
                } else {
                    // 数据不足，平均分配
                    for (const typeName of Object.keys(scores)) {
                        scores[typeName] = 0.25;
                    }
                }
                
                return scores;
            }
            
            // 获取相反类型
            getOppositeTypes(typeName) {
                const opposites = {
                    "大单": ["小双"],
                    "大双": ["小单"],
                    "小单": ["大双"],
                    "小双": ["大单"]
                };
                return opposites[typeName] || [];
            }
            
            // 更新AI分析状态
            updateAIAnalysisState(data, strongType) {
                this.algorithm_state.ai_analysis_state = {
                    'strong_type': strongType,
                    'trend_direction': this.trend_analysis.short_term_trend,
                    'trend_consistency': this.trend_analysis.trend_consistency,
                    'momentum_index': this.time_analysis.momentum_index,
                    'volatility_level': this.trend_analysis.volatility_level,
                    'timestamp': new Date()
                };
            }
            
            // 基于强势类型生成双组预测
            generateDoublePredictionBasedOnStrongType(data, strongType) {
                // 强势类型作为第一个预测类型
                const finalTypes = [strongType];
                
                // 选择第二个类型（与强势类型互补）
                const allTypes = ["大单", "大双", "小单", "小双"];
                const remainingTypes = allTypes.filter(t => t !== strongType);
                
                // 根据各种分析选择第二个类型
                const secondTypeScores = {};
                for (const typeName of remainingTypes) {
                    let score = 0;
                    
                    // 基于趋势分析
                    const trendScore = this.calculateTrendBasedScore(data);
                    score += trendScore[typeName] * 0.3;
                    
                    // 基于遗漏分析
                    const omissionScore = this.calculateOmissionBasedScore(data);
                    score += omissionScore[typeName] * 0.25;
                    
                    // 基于模式识别
                    const patternScore = this.calculatePatternBasedScore(data);
                    score += patternScore[typeName] * 0.2;
                    
                    // 基于时间模式
                    const timeScore = this.calculateTimeBasedScore(data);
                    score += timeScore[typeName] * 0.15;
                    
                    // 基于历史平衡
                    const balanceScore = 1 - (this.algorithm_state.type_balance[typeName] || 0.25);
                    score += balanceScore * 0.1;
                    
                    secondTypeScores[typeName] = score;
                }
                
                // 选择分数最高的作为第二个类型
                let secondType = remainingTypes[0];
                let maxScore = secondTypeScores[secondType];
                
                for (const [typeName, score] of Object.entries(secondTypeScores)) {
                    if (score > maxScore) {
                        maxScore = score;
                        secondType = typeName;
                    }
                }
                
                finalTypes.push(secondType);
                
                return finalTypes;
            }
            
            // 基于AI分析状态选择杀组
            selectKillBasedOnAIState(finalTypes, predictedType, data, strongType) {
                // 首先尝试使用杀组算法
                const [algorithmKill, algorithmConfidence] = this.enhancedKillAlgorithm(data);
                
                // 检查杀组算法结果是否与AI分析状态一致
                if (algorithmKill && algorithmConfidence > 60) {
                    // 杀组不能是强势类型，也不能是预测的双组
                    if (algorithmKill !== strongType && 
                        !finalTypes.includes(algorithmKill) &&
                        algorithmKill !== predictedType) {
                        return algorithmKill;
                    }
                }
                
                // 如果杀组算法不可用或与AI状态不一致，使用AI状态选择杀组
                const allTypes = ["大单", "大双", "小单", "小双"];
                
                // 杀组候选：不能是强势类型，不能是预测的双组，不能是球预测类型
                let killCandidates = allTypes.filter(
                    t => t !== strongType && 
                         !finalTypes.includes(t) && 
                         t !== predictedType
                );
                
                if (killCandidates.length === 0) {
                    // 如果没有候选，放宽条件：只要不是强势类型
                    killCandidates = allTypes.filter(t => t !== strongType);
                }
                
                if (killCandidates.length === 0) {
                    // 如果还是没有候选，使用所有类型
                    killCandidates = allTypes;
                }
                
                // 计算每个候选的杀组分数
                const killScores = {};
                for (const candidate of killCandidates) {
                    let score = 0;
                    
                    // 遗漏值分数（遗漏越久，越不适合作为杀组）
                    const recentTypes = data.slice(0, 15).map(item => item.type);
                    if (recentTypes.includes(candidate)) {
                        const lastIndex = recentTypes.length - 1 - [...recentTypes].reverse().indexOf(candidate);
                        const omission = lastIndex;
                        score += (1 - omission / recentTypes.length) * 30;
                    }
                    
                    // 趋势分数（与强势类型相反的更适合作为杀组）
                    if (this.isOppositeType(candidate, strongType)) {
                        score += 25;
                    }
                    
                    // 波动性分数（高波动性下，所有类型都有可能）
                    const volatility = this.trend_analysis.volatility_level;
                    score += (1 - volatility) * 20;
                    
                    // 历史使用频率
                    const killCount = this.algorithm_state.kill_count[candidate] || 0;
                    score += (1 - Math.min(killCount / 8, 1)) * 25;
                    
                    killScores[candidate] = score;
                }
                
                if (Object.keys(killScores).length > 0) {
                    let bestKill = killCandidates[0];
                    let maxScore = killScores[bestKill];
                    
                    for (const [candidate, score] of Object.entries(killScores)) {
                        if (score > maxScore) {
                            maxScore = score;
                            bestKill = candidate;
                        }
                    }
                    
                    // 记录杀组使用历史
                    this.algorithm_state.kill_count[bestKill] = (this.algorithm_state.kill_count[bestKill] || 0) + 1;
                    return bestKill;
                } else {
                    // 最后的手段：选择与强势类型不同的类型
                    const candidates = allTypes.filter(t => t !== strongType);
                    const bestKill = candidates.length > 0 ? 
                        candidates[Math.floor(Math.random() * candidates.length)] : 
                        allTypes[Math.floor(Math.random() * allTypes.length)];
                    this.algorithm_state.kill_count[bestKill] = (this.algorithm_state.kill_count[bestKill] || 0) + 1;
                    return bestKill;
                }
            }
            
            // 判断两个类型是否相反
            isOppositeType(type1, type2) {
                const opposites = {
                    "大单": ["小双"],
                    "大双": ["小单"],
                    "小单": ["大双"],
                    "小双": ["大单"]
                };
                return opposites[type1] && opposites[type1].includes(type2);
            }
            
            // 基于球预测的核心预测算法
            sumBasedPrediction(data) {
                if (data.length < 5) {
                    return ["大单大双", "大双", [0, 0, 0], [50, 50, 50]];
                }
                
                // 更新球分析
                this.updateBallAnalysis(data);
                
                // 预测三个球
                const [predictedBalls, ballConfidences] = this.predictBallsEnhanced(data);
                
                // 同时分析AI状态和杀组推荐，确保结果一致
                let [finalResult, killResult] = this.analyzeAIStateAndKill(data, predictedBalls);
                
                // 最终验证：确保球预测类型与杀组不同
                const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
                const predictedType = this.sumToType(predictedSum);
                
                if (predictedType === killResult) {
                    // 如果仍然相同，强制更改杀组
                    const allTypes = ["大单", "大双", "小单", "小双"];
                    let killCandidates = allTypes.filter(t => t !== predictedType);
                    if (killCandidates.length > 0) {
                        // 选择与强势类型不同的
                        const strongType = this.algorithm_state.strong_type;
                        killCandidates = killCandidates.filter(t => t !== strongType);
                        if (killCandidates.length > 0) {
                            killResult = killCandidates[Math.floor(Math.random() * killCandidates.length)];
                        }
                    }
                }
                
                // 自适应学习
                this.adaptiveLearning(data, 0.5);  // 暂时使用固定准确率，实际应该根据历史结果调整
                
                return [finalResult, killResult, predictedBalls, ballConfidences];
            }
            
            // 和值转类型
            sumToType(sumVal) {
                if (sumVal <= 13) {
                    return (sumVal % 2 === 0) ? "小双" : "小单";
                } else {
                    return (sumVal % 2 === 0) ? "大双" : "大单";
                }
            }
            
            // 计算置信度
            calculateConfidence(data, finalResult, killResult, ballConfidences) {
                if (data.length < 5) {
                    return [60, 55, 50];
                }
                
                let baseConfidence = 65;
                let killConfidence = 60;
                let ballConfidence = ballConfidences.length > 0 ? 
                    ballConfidences.reduce((a, b) => a + b, 0) / ballConfidences.length : 50;
                
                // 数据量置信度
                if (data.length >= 80) {
                    baseConfidence += 20;
                    killConfidence += 15;
                    ballConfidence += 15;
                } else if (data.length >= 50) {
                    baseConfidence += 15;
                    killConfidence += 10;
                    ballConfidence += 10;
                } else if (data.length >= 30) {
                    baseConfidence += 10;
                    killConfidence += 8;
                    ballConfidence += 8;
                } else if (data.length >= 20) {
                    baseConfidence += 5;
                    killConfidence += 5;
                    ballConfidence += 5;
                }
                
                // 球预测质量
                if (ballConfidence > 75) {
                    baseConfidence += 12;
                    killConfidence += 8;
                } else if (ballConfidence > 65) {
                    baseConfidence += 8;
                    killConfidence += 5;
                }
                
                // 预测与杀组差异
                const predictedTypes = [];
                for (let i = 0; i < finalResult.length; i += 2) {
                    predictedTypes.push(finalResult.substring(i, i + 2));
                }
                
                if (!predictedTypes.includes(killResult)) {
                    baseConfidence += 8;
                    killConfidence += 8;
                }
                
                // AI状态一致性置信度
                const strongType = this.algorithm_state.strong_type;
                if (strongType && predictedTypes.includes(strongType)) {
                    baseConfidence += 10;
                    killConfidence += 5;
                }
                
                // 时间模式置信度
                const currentHour = new Date().getHours();
                const hourConfidence = this.time_analysis.hourly_patterns[currentHour] * 20;
                baseConfidence += hourConfidence;
                killConfidence += hourConfidence * 0.8;
                
                // 趋势强度置信度
                const trendConfidence = this.time_analysis.trend_strength * 15;
                baseConfidence += trendConfidence;
                ballConfidence += trendConfidence;
                
                // 自适应学习置信度
                const adaptationConfidence = (this.algorithm_state.adaptation_factor - 0.5) * 10;
                baseConfidence += adaptationConfidence;
                
                // 趋势一致性置信度
                const consistencyConfidence = this.trend_analysis.trend_consistency * 12;
                baseConfidence += consistencyConfidence;
                killConfidence += consistencyConfidence * 0.7;
                
                // 动量指数置信度
                const momentumConfidence = Math.abs(this.time_analysis.momentum_index - 0.5) * 20;
                baseConfidence += momentumConfidence;
                
                // 杀组算法置信度
                const [algorithmKill, algorithmConfidence] = this.enhancedKillAlgorithm(data);
                if (algorithmKill === killResult && algorithmConfidence > 60) {
                    killConfidence += 10;
                }
                
                return [
                    Math.min(95, Math.max(50, baseConfidence)),
                    Math.min(90, Math.max(40, killConfidence)),
                    Math.min(95, ballConfidence)
                ];
            }
            
            // 生成精准的特码
            generatePreciseCodes(data, finalResult, predictedBalls) {
                if (data.length < 5) {
                    return [7, 13, 19, 25];
                }
                
                const predictedTypes = [];
                if (finalResult && finalResult.length >= 4) {
                    for (let i = 0; i < finalResult.length; i += 2) {
                        predictedTypes.push(finalResult.substring(i, i + 2));
                    }
                } else {
                    predictedTypes = ["大单", "大双"];
                }
                
                const specialCodes = [];
                
                // 基于预测类型生成特码
                for (const predType of predictedTypes) {
                    if (predType === "大单") {
                        // 大单特码：15, 17, 19, 21, 23, 25, 27
                        const preferredCodes = [17, 19, 21, 23];
                        // 根据时间模式调整
                        const currentHour = new Date().getHours();
                        if ([10, 14, 18, 22].includes(currentHour)) {  // 高峰时段
                            preferredCodes.splice(0, 4, 19, 21, 23, 25);
                        }
                        const selected = this.getRandomElements(preferredCodes, Math.min(2, preferredCodes.length));
                        specialCodes.push(...selected);
                    } else if (predType === "大双") {
                        // 大双特码：14, 16, 18, 20, 22, 24, 26
                        const preferredCodes = [16, 18, 20, 22];
                        const currentHour = new Date().getHours();
                        if ([10, 14, 18, 22].includes(currentHour)) {
                            preferredCodes.splice(0, 4, 18, 20, 22, 24);
                        }
                        const selected = this.getRandomElements(preferredCodes, Math.min(2, preferredCodes.length));
                        specialCodes.push(...selected);
                    } else if (predType === "小单") {
                        // 小单特码：1, 3, 5, 7, 9, 11, 13
                        const preferredCodes = [5, 7, 9, 11];
                        const currentHour = new Date().getHours();
                        if ([2, 6, 12, 20].includes(currentHour)) {  // 特殊时段
                            preferredCodes.splice(0, 4, 7, 9, 11, 13);
                        }
                        const selected = this.getRandomElements(preferredCodes, Math.min(2, preferredCodes.length));
                        specialCodes.push(...selected);
                    } else {  // 小双
                        // 小双特码：0, 2, 4, 6, 8, 10, 12
                        const preferredCodes = [4, 6, 8, 10];
                        const currentHour = new Date().getHours();
                        if ([2, 6, 12, 20].includes(currentHour)) {
                            preferredCodes.splice(0, 4, 6, 8, 10, 12);
                        }
                        const selected = this.getRandomElements(preferredCodes, Math.min(2, preferredCodes.length));
                        specialCodes.push(...selected);
                    }
                }
                
                // 添加基于球预测的特码
                const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
                if (predictedSum >= 0 && predictedSum <= 27 && !specialCodes.includes(predictedSum)) {
                    specialCodes.push(predictedSum);
                }
                
                // 基于AI强势类型添加特码
                const strongType = this.algorithm_state.strong_type;
                if (strongType) {
                    let strongCodes;
                    if (strongType === "大单") {
                        strongCodes = [19, 21, 23];
                    } else if (strongType === "大双") {
                        strongCodes = [18, 20, 22];
                    } else if (strongType === "小单") {
                        strongCodes = [7, 9, 11];
                    } else {  // 小双
                        strongCodes = [6, 8, 10];
                    }
                    
                    for (const code of strongCodes) {
                        if (!specialCodes.includes(code) && specialCodes.length < 4) {
                            specialCodes.push(code);
                            break;
                        }
                    }
                }
                
                // 确保特码数量为4个
                while (specialCodes.length < 4) {
                    // 添加一些补充特码
                    const allCodes = Array.from({length: 28}, (_, i) => i);
                    // 排除已选择的特码
                    const availableCodes = allCodes.filter(c => !specialCodes.includes(c));
                    // 选择与预测类型相符的补充特码
                    for (const predType of predictedTypes) {
                        let typeCodes;
                        if (predType === "大单") {
                            typeCodes = availableCodes.filter(c => c >= 14 && c % 2 === 1);
                        } else if (predType === "大双") {
                            typeCodes = availableCodes.filter(c => c >= 14 && c % 2 === 0);
                        } else if (predType === "小单") {
                            typeCodes = availableCodes.filter(c => c <= 13 && c % 2 === 1);
                        } else {  // 小双
                            typeCodes = availableCodes.filter(c => c <= 13 && c % 2 === 0);
                        }
                        
                        if (typeCodes.length > 0 && specialCodes.length < 4) {
                            const randomCode = typeCodes[Math.floor(Math.random() * typeCodes.length)];
                            specialCodes.push(randomCode);
                        }
                    }
                }
                
                // 如果还是不足4个，随机补充
                while (specialCodes.length < 4) {
                    const allCodes = Array.from({length: 28}, (_, i) => i);
                    const availableCodes = allCodes.filter(c => !specialCodes.includes(c));
                    if (availableCodes.length > 0) {
                        const randomCode = availableCodes[Math.floor(Math.random() * availableCodes.length)];
                        specialCodes.push(randomCode);
                    } else {
                        break;
                    }
                }
                
                return specialCodes.slice(0, 4);
            }
            
            // 从数组中随机选择指定数量的元素
            getRandomElements(array, count) {
                const shuffled = [...array].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }
            
            // 获取下一期期号的后两位
            getNextPeriodNumber(data) {
                if (!data || data.length === 0) {
                    return "00";
                }
                
                // 获取最新期号
                let latestPeriod;
                if (Array.isArray(data)) {
                    // 网络数据
                    latestPeriod = data[0].period;
                } else {
                    // 手动输入数据
                    // 这里简化处理，实际应用中可能需要解析
                    latestPeriod = "000000";
                }
                
                // 提取数字部分
                const periodDigits = latestPeriod.replace(/\D/g, '');
                if (!periodDigits) {
                    return "00";
                }
                
                // 计算下一期期号
                try {
                    let nextPeriod = parseInt(periodDigits) + 1;
                    // 取后两位，如果到99后回到00
                    const nextPeriodLastTwo = nextPeriod % 100;
                    // 格式化为两位数字符串
                    return nextPeriodLastTwo.toString().padStart(2, '0');
                } catch (e) {
                    return "00";
                }
            }
            
            // 生成预测历史记录
            generatePredictionHistory(data) {
                if (data.length < 10) {
                    return [];
                }
                
                const history = [];
                const limit = Math.min(50, data.length - 1);
                
                for (let i = 0; i < limit; i++) {
                    const trainingData = data.slice(i + 1);
                    const testPeriod = data[i];
                    
                    // 使用训练数据预测
                    const [finalResult, killResult, predictedBalls, ballConfidences] = this.sumBasedPrediction(trainingData);
                    
                    // 验证是否命中
                    const predictedTypes = [];
                    for (let j = 0; j < finalResult.length; j += 2) {
                        predictedTypes.push(finalResult.substring(j, j + 2));
                    }
                    
                    // 计算命中结果
                    let hitResult = "未中";
                    if (predictedTypes.includes(testPeriod.type)) {
                        hitResult = "中双组";
                    }
                    
                    // 检查杀组是否正确（杀组意思：下一期不会出现的组合）
                    // 如果开奖类型不等于杀组，则杀组命中
                    const killHit = testPeriod.type !== killResult;
                    
                    history.push({
                        period: testPeriod.period,
                        timeStr: testPeriod.timeStr,
                        numbers: testPeriod.numbers,
                        sum: testPeriod.sum,
                        type: testPeriod.type,
                        killPrediction: killResult,
                        prediction: finalResult,
                        hit: hitResult,
                        killHit: killHit
                    });
                }
                
                return history;
            }
            
            // 计算准确率统计
            calculateAccuracyStats(history) {
                if (!history || history.length === 0) {
                    return {
                        total: 0,
                        hit: 0,
                        killHit: 0,
                        accuracy: 0,
                        killAccuracy: 0
                    };
                }
                
                const total = history.length;
                const hit = history.filter(item => item.hit === "中双组").length;
                const killHit = history.filter(item => item.killHit).length;
                const accuracy = total > 0 ? (hit / total) * 100 : 0;
                const killAccuracy = total > 0 ? (killHit / total) * 100 : 0;
                
                return {
                    total: total,
                    hit: hit,
                    killHit: killHit,
                    accuracy: Math.round(accuracy),
                    killAccuracy: Math.round(killAccuracy)
                };
            }
        }

        // 算法切换逻辑
        document.querySelectorAll('.algorithm-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const algorithm = this.getAttribute('data-algorithm');
                
                // 更新标签页状态
                document.querySelectorAll('.algorithm-tab').forEach(t => {
                    t.classList.remove('active');
                });
                this.classList.add('active');
                
                // 更新内容区域
                document.querySelectorAll('.algorithm-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`algorithm${algorithm}-content`).classList.add('active');
                
                // 更新算法描述
                const algorithmDescription = document.getElementById('algorithmDescription');
                if (algorithm === '1') {
                    algorithmDescription.textContent = '基于AI强势分析的预测算法 | 整合算法 + 杀组逻辑 + 双组预测';
                } else {
                    algorithmDescription.textContent = '基于AI强势分析的预测算法 | 强势类型分析 + 一致性杀组推荐';
                }
            });
        });
        
        // 创建预测器实例
        const predictor1 = new PC28Predictor();
        const predictor2 = new PC28PredictorV2();

        // 算法切换逻辑
        document.querySelectorAll('.algorithm-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const algorithm = this.getAttribute('data-algorithm');
                
                // 更新标签页状态
                document.querySelectorAll('.algorithm-tab').forEach(t => {
                    t.classList.remove('active');
                });
                this.classList.add('active');
                
                // 更新内容区域
                document.querySelectorAll('.algorithm-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(`algorithm${algorithm}-content`).classList.add('active');
                
                // 更新算法描述
                const algorithmDescription = document.getElementById('algorithmDescription');
                if (algorithm === '1') {
                    algorithmDescription.textContent = '基于AI强势分析的预测算法 | 整合算法 + 杀组逻辑 + 双组预测';
                } else {
                    algorithmDescription.textContent = '基于AI强势分析的预测算法 | 强势类型分析 + 一致性杀组推荐';
                }
            });
        });

        // 算法一的事件监听
        document.getElementById('fetchData1').addEventListener('click', () => {
            executePrediction(1);
        });

        document.getElementById('copyFinalResult1').addEventListener('click', function() {
            copyFinalResult(1, this);
        });

        // 算法二的事件监听
        document.getElementById('fetchData2').addEventListener('click', () => {
            executePrediction(2);
        });

        document.getElementById('copyFinalResult2').addEventListener('click', function() {
            copyFinalResult(2, this);
        });

        // 执行预测
        async function executePrediction(algorithmNumber) {
            const loadingDiv = document.getElementById(`loading${algorithmNumber}`);
            const resultsDiv = document.getElementById(`results${algorithmNumber}`);
            
            loadingDiv.style.display = 'block';
            resultsDiv.style.display = 'none';
            
            try {
                // 根据算法编号选择预测器
                const predictor = algorithmNumber === 1 ? predictor1 : predictor2;
                
                // 获取彩票数据
                const rawData = await predictor.fetchLotteryData(100);
                if (!rawData || rawData.length === 0) {
                    alert('无法从网络获取数据');
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // 解析数据
                const periods = predictor.parseNetworkData(rawData);
                if (!periods || periods.length === 0) {
                    alert('网络数据解析失败');
                    loadingDiv.style.display = 'none';
                    return;
                }
                
                // 执行预测
                const [finalResult, killResult, predictedBalls, ballConfidences] = predictor.sumBasedPrediction(periods);
                
                // 计算置信度
                const [baseConfidence, killConfidence, ballConfidence] = predictor.calculateConfidence(
                    periods, finalResult, killResult, ballConfidences);
                
                // 生成特码
                const specialCodes = predictor.generatePreciseCodes(periods, finalResult, predictedBalls);
                
                // 生成预测历史记录
                const predictionHistory = predictor.generatePredictionHistory(periods);
                
                // 计算准确率统计
                const accuracyStats = predictor.calculateAccuracyStats(predictionHistory);
                
                // 计算期号算法预测
                const periodPrediction = predictor.calculatePeriodBasedPrediction ? 
                    predictor.calculatePeriodBasedPrediction(periods) : null;
                
                // 计算新杀组算法预测
                const killPrediction = predictor.calculateKillByNewAlgorithm ? 
                    predictor.calculateKillByNewAlgorithm(periods) : null;
                
                // 显示结果
                displayResults(
                    algorithmNumber,
                    finalResult, killResult, specialCodes, 
                    baseConfidence, killConfidence, ballConfidence,
                    predictedBalls, ballConfidences, periods, predictionHistory, accuracyStats,
                    periodPrediction, killPrediction
                );
                
                loadingDiv.style.display = 'none';
                resultsDiv.style.display = 'block';
                
            } catch (error) {
                console.error('预测过程中出错:', error);
                alert('预测过程中出错: ' + error.message);
                loadingDiv.style.display = 'none';
            }
        }

        // 复制最终结果
        function copyFinalResult(algorithmNumber, buttonElement) {
            const finalOutput = document.getElementById(`finalOutput${algorithmNumber}`);
            const textArea = document.createElement('textarea');
            textArea.value = finalOutput.textContent;
            document.body.appendChild(textArea);
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            
            // 显示复制成功提示
            const originalText = buttonElement.textContent;
            buttonElement.textContent = '已复制到剪贴板！';
            buttonElement.classList.add('copy-success');
            
            setTimeout(() => {
                buttonElement.textContent = originalText;
                buttonElement.classList.remove('copy-success');
            }, 2000);
        }

        // 显示预测结果
        function displayResults(
            algorithmNumber,
            finalResult, killResult, specialCodes, 
            baseConfidence, killConfidence, ballConfidence,
            predictedBalls, ballConfidences, data, predictionHistory, accuracyStats,
            periodPrediction, killPrediction
        ) {
            // 更新UI元素
            document.getElementById(`finalResult${algorithmNumber}`).textContent = finalResult;
            document.getElementById(`baseConfidence${algorithmNumber}`).textContent = `置信度: ${Math.round(baseConfidence)}%`;
            
            document.getElementById(`killResult${algorithmNumber}`).textContent = killResult;
            document.getElementById(`killConfidence${algorithmNumber}`).textContent = `置信度: ${Math.round(killConfidence)}%`;
            
            document.getElementById(`specialCodes${algorithmNumber}`).textContent = specialCodes.map(code => code.toString().padStart(2, '0')).join(' ');
            
            document.getElementById(`ballA${algorithmNumber}`).textContent = `${predictedBalls[0]} (${Math.round(ballConfidences[0])}%)`;
            document.getElementById(`ballB${algorithmNumber}`).textContent = `${predictedBalls[1]} (${Math.round(ballConfidences[1])}%)`;
            document.getElementById(`ballC${algorithmNumber}`).textContent = `${predictedBalls[2]} (${Math.round(ballConfidences[2])}%)`;
            
            const predictedSum = predictedBalls.reduce((a, b) => a + b, 0);
            document.getElementById(`predictedSum${algorithmNumber}`).textContent = `${predictedSum}`;
            
            // 显示期号算法结果
            const periodCalculation = document.getElementById(`periodCalculation${algorithmNumber}`);
            const periodResult = document.getElementById(`periodResult${algorithmNumber}`);
            
            if (periodPrediction) {
                periodCalculation.textContent = periodPrediction.calculation;
                periodResult.textContent = `预测结果: ${periodPrediction.result} (${periodPrediction.type})`;
            } else {
                periodCalculation.textContent = "数据不足，无法计算";
                periodResult.textContent = "无法预测";
            }
            
            // 显示杀组算法结果
            const killCalculation = document.getElementById(`killCalculation${algorithmNumber}`);
            const killAlgorithmResult = document.getElementById(`killAlgorithmResult${algorithmNumber}`);
            
            if (killPrediction) {
                killCalculation.textContent = killPrediction.calculation;
                killAlgorithmResult.textContent = `杀组预测: ${killPrediction.value} (${killPrediction.type})`;
            } else {
                killCalculation.textContent = "数据不足，无法计算";
                killAlgorithmResult.textContent = "无法预测";
            }
            
            // 生成最终结果字符串
            const predictor = algorithmNumber === 1 ? predictor1 : predictor2;
            const nextPeriod = predictor.getNextPeriodNumber(data);
            const formattedCodes = specialCodes.map(code => code.toString().padStart(2, '0')).join(' ');
            
            const finalOutputText = `${nextPeriod} 杀${killResult} ${finalResult} ${formattedCodes}`;
            
            document.getElementById(`finalOutput${algorithmNumber}`).textContent = finalOutputText;
            
            // 显示预测历史记录
            displayPredictionHistory(algorithmNumber, predictionHistory);
            
            // 显示准确率统计
            displayAccuracyStats(algorithmNumber, accuracyStats);
        }
        
        // 显示预测历史记录
        function displayPredictionHistory(algorithmNumber, history) {
            const predictionTable = document.getElementById(`predictionTable${algorithmNumber}`);
            const tbody = predictionTable.querySelector('tbody');
            tbody.innerHTML = '';
            
            if (!history || history.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6">暂无预测记录</td></tr>';
                return;
            }
            
            history.forEach(item => {
                const row = document.createElement('tr');
                
                let hitClass = '';
                let hitSymbol = '';
                
                if (item.killHit) {
                    hitClass = 'hit';
                    hitSymbol = '🀄️';
                } else {
                    hitClass = 'miss';
                    hitSymbol = '❌🀄️';
                }
                
                row.innerHTML = `
                    <td>${item.period}</td>
                    <td>${item.timeStr}</td>
                    <td>${item.numbers.join('+')}=${item.sum}</td>
                    <td>杀${item.killPrediction}</td>
                    <td>${item.prediction}</td>
                    <td class="${hitClass}">${hitSymbol}</td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        // 显示准确率统计
        function displayAccuracyStats(algorithmNumber, stats) {
            const accuracySummary = document.getElementById(`accuracySummary${algorithmNumber}`);
            
            if (stats.total === 0) {
                accuracySummary.innerHTML = '暂无统计信息';
                return;
            }
            
            const hitRate = stats.killHit / stats.total * 100;
            
            accuracySummary.innerHTML = `
                近${stats.total}期预测准确率: ${stats.killHit}/${stats.total} = ${Math.round(hitRate)}%<br>
                <small>白云预测仅供参考 谨慎投资</small>
            `;
        }
    </script>
</body>
</html>